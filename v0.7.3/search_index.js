var documenterSearchIndex = {"docs":
[{"location":"lib/Integrate/#Maranatha.Integrate","page":"Integrate","title":"Maranatha.Integrate","text":"","category":"section"},{"location":"lib/Integrate/#Maranatha.Integrate._NS_BETA_CACHE","page":"Integrate","title":"Maranatha.Integrate._NS_BETA_CACHE","text":"_NS_BETA_CACHE :: Dict{Tuple{Int,Symbol,Int}, Vector{Float64}}\n\nCache for Float64 composite Newton-Cotes coefficient vectors.\n\nDescription\n\nThis dictionary stores previously constructed global coefficient vectors beta (after conversion to Float64) to avoid repeated expensive exact-rational assembly.\n\nThe cache key is:\n\n(p, boundary, Nsub)\n\nwhere:\n\np        : local Newton-Cotes node count (e.g. 3, 4, 5, ...)\nboundary : boundary pattern (:LCRC, :LORC, :LCRO, :LORO)\nNsub     : number of global subintervals\n\nThe stored value is:\n\nVector{Float64}  # length Nsub + 1\n\nrepresenting the global coefficient vector β such that:\n\ntextttws_j = beta_j  h\n\nwith displaystyleh = fracb-aN_textsub.\n\nPurpose\n\nExact rational assembly via _assemble_composite_beta_rational can be computationally heavy for large p or repeated calls. This cache ensures that identical quadrature configurations reuse previously computed weights.\n\nNotes\n\nThe cache is process-local (not persistent across sessions).\nMemory usage grows with distinct (p, boundary, Nsub) triples.\nSafe for repeated deterministic use since values are immutable Vector{Float64}.\n\n\n\n\n\n","category":"constant"},{"location":"lib/Integrate/#Maranatha.Integrate.RBig","page":"Integrate","title":"Maranatha.Integrate.RBig","text":"RBig = Rational{BigInt}\n\nExact rational number type used for composite Newton-Cotes weight assembly.\n\nDescription\n\nRBig is defined as:\n\nRational{BigInt}\n\nand is used throughout the exact composite Newton-Cotes construction to guarantee that:\n\nAll local moment integrals are computed exactly.\nAll Vandermonde systems for local weights alpha are solved in exact arithmetic.\nThe assembled global coefficient vector beta is mathematically exact before conversion to Float64.\n\nThis prevents any floating-point contamination during symbolic-like weight construction.\n\nDesign rationale\n\nComposite Newton-Cotes weights can involve large rational coefficients. Using Rational{BigInt} ensures:\n\nNo loss of precision during assembly.\nExact cancellation between overlapping local blocks.\nDeterministic reproducibility independent of floating-point rounding.\n\nConversion to Float64 happens only in _get_beta_float.\n\n\n\n\n\n","category":"type"},{"location":"lib/Integrate/#Maranatha.Integrate._assemble_composite_beta_rational-Tuple{Int64, Symbol, Int64}","page":"Integrate","title":"Maranatha.Integrate._assemble_composite_beta_rational","text":"_assemble_composite_beta_rational(\n    p::Int, \n    boundary::Symbol, \n    Nsub::Int\n) -> Vector{RBig}\n\nAssemble the global composite Newton-Cotes coefficient vector beta in exact rational form.\n\nFunction description\n\nThis is the core exact assembly routine. It builds a global coefficient vector beta (length N_textsub+1) such that the composite quadrature weights are:\n\ntextttws_j = beta_j  h  quad textwith quad h = fracb-aN_textsub\n\nThe algorithm:\n\nValidates the tiling constraint via _check_condition.\nBuilds the left boundary block (closed or opened as requested).\nAdds m interior closed blocks (each width p-1).\nBuilds the right boundary block (closed or opened as requested).\nAccumulates all contributions into a single global beta.\n\nAll computations remain in RBig = Rational{BigInt} to preserve exactness.\n\nArguments\n\np: Local node count (NC order in this implementation; must satisfy p ge 2).\nboundary: Boundary pattern (:LCRC, :LORC, :LCRO, :LORO).\nNsub: Number of global subintervals (must satisfy the composite constraint).\n\nReturns\n\nVector{RBig}: Exact global coefficient vector beta of length N_textsub+1.\n\nErrors\n\nThrows (via helper checks) if the composite constraint fails or if internal assembly mismatches occur.\n\nPerformance notes\n\nFor large p the exact rational weights can become extremely large; this may be slow and memory-heavy even before conversion to Float64.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate._check_condition-Tuple{Int64, Symbol, Int64}","page":"Integrate","title":"Maranatha.Integrate._check_condition","text":"_check_condition(\n    p::Int, \n    boundary::Symbol, \n    Nsub::Int\n) -> (m, wL, wR)\n\nValidate and decode the composite tiling constraint for exact Newton-Cotes assembly.\n\nFunction description\n\nThe composite construction must tile the global interval 0 N_textsub (in units of h) using:\n\none left boundary block of width w_L,\nm interior closed blocks each of width p-1,\none right boundary block of width w_R.\n\nThe required constraint is:\n\nN_textsub = w_L + m  (p - 1) + w_R\n\nwhere w_L / w_R depend on the boundary pattern (:LCRC, :LORC, :LCRO, :LORO).\n\nThis function checks:\n\nN_textsub ge w_L + w_R, and\n(N_textsub - w_L - w_R) divisible by (p-1).\n\nIf invalid, it throws with a message that includes nearby valid N_textsub values.\n\nArguments\n\np: Local node count (must satisfy p ge 2).\nboundary: Boundary pattern symbol.\nNsub: Number of subintervals for the global composite rule (must satisfy N_textsub ge 1).\n\nReturns\n\nm::Int: Number of interior closed blocks.\nwL::Int: Left block width in units of h.\nwR::Int: Right block width in units of h.\n\nErrors\n\nThrows (via Maranatha.JobLoggerTools.error_benji) if constraints are violated.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate._compute_local_alpha-Tuple{Int64, Symbol, Symbol}","page":"Integrate","title":"Maranatha.Integrate._compute_local_alpha","text":"_compute_local_alpha(\n    p::Int, \n    kind::Symbol, \n    which_open::Symbol\n) -> (nodes, α, w_int)\n\nCompute local Newton-Cotes weights alpha on the dimensionless interval 0 w.\n\nFunction description\n\nThis helper constructs the moment-matching linear system for a local block:\n\nChoose local nodes u_j depending on kind / which_open.\nSet w (in units of h) via _local_width(p, kind).\nSolve the Vandermonde-like system:\n\nsum_j alpha_j  u_j^k = intlimits_0^w du  u^k  quad textfor quad k = 0  ldots  p-1\n\nAll computations are performed in exact rational arithmetic (RBig) so that the assembled composite weights are exact before conversion to Float64.\n\nArguments\n\np: Number of nodes in the local block (must satisfy p ge 2).\nkind: Either :closed or :opened.\nwhich_open: For opened blocks, either :backward or :forward.\n\nReturns\n\nnodes::Vector{RBig}: Local node positions in dimensionless units.\nα::Vector{RBig}: Exact local weights satisfying moment matching on 0 w.\nw_int::Int: Local interval width w in units of h.\n\nErrors\n\nThrows (via downstream helpers) if arguments are invalid or if the solve fails.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate._decode_boundary-Tuple{Symbol}","page":"Integrate","title":"Maranatha.Integrate._decode_boundary","text":"_decode_boundary(\n    boundary::Symbol\n) -> Tuple{Symbol,Symbol}\n\nDecode a composite boundary pattern symbol into the left/right local rule kinds.\n\nFunction description\n\nThis helper maps the global boundary pattern used by the exact-rational composite Newton-Cotes assembly into the local endpoint kinds:\n\n:closed means the local block includes the endpoint node.\n:opened means the local block is shifted (open-type block).\n\nSupported boundary patterns are:\n\n:LCRC (Left Closed, Right Closed)\n:LORC (Left Opened, Right Closed)\n:LCRO (Left Closed, Right Opened)\n:LORO (Left Opened, Right Opened)\n\nArguments\n\nboundary: Boundary pattern symbol.\n\nReturns\n\n(Ltype, Rtype): A tuple of symbols, each either :closed or :opened.\n\nErrors\n\nThrows (via JobLoggerTools.error_benji) if boundary is not one of the supported symbols.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate._exact_moment_0w-Tuple{Rational{BigInt}, Int64}","page":"Integrate","title":"Maranatha.Integrate._exact_moment_0w","text":"_exact_moment_0w(\n    w::RBig, \n    k::Int\n) -> RBig\n\nCompute the exact monomial moment displaystyleintlimits_0^w du  u^k as a rational number.\n\nFunction description\n\nThis routine returns the closed-form value\n\ndisplaystyleintlimits_0^w du  u^k = fracw^k+1k+1\n\nusing exact rational arithmetic (RBig) to avoid any rounding during the moment-matching solve for local Newton-Cotes weights.\n\nArguments\n\nw: Upper limit of the local integration interval (dimensionless), as RBig.\nk: Monomial power (assumed k ge 0 in intended usage).\n\nReturns\n\nRBig: The exact moment value.\n\nErrors\n\nNo explicit checks are performed; invalid k may lead to unintended behavior.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate._get_beta_float-Tuple{Int64, Symbol, Int64}","page":"Integrate","title":"Maranatha.Integrate._get_beta_float","text":"_get_beta_float(\n    p::Int, \n    boundary::Symbol, \n    Nsub::Int\n) -> Vector{Float64}\n\nGet the global composite coefficient vector beta in Float64, with optional caching.\n\nFunction description\n\nThis routine is the Float64-facing wrapper around the exact rational assembly:\n\nCheck the cache _NS_BETA_CACHE using key (p, boundary, Nsub).\nIf missing, build beta exactly via _assemble_composite_beta_rational.\nConvert each RBig entry to Float64.\nStore the result in the cache and return it.\n\nThe returned vector beta has length N_textsub+1 and is intended to be scaled by h to produce quadrature weights ws.\n\nArguments\n\np: Local node count (must satisfy p ge 2).\nboundary: Boundary pattern symbol (:LCRC, :LORC, :LCRO, :LORO).\nNsub: Number of subintervals (must satisfy the composite constraint for the given boundary).\n\nReturns\n\nVector{Float64}: The coefficient vector beta (length N_textsub+1) in Float64.\n\nErrors\n\nPropagates any error from _assemble_composite_beta_rational and its validators.\n\nPerformance notes\n\nThe cache is recommended when repeatedly calling the same (p, boundary, Nsub).\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate._is_ns_rule-Tuple{Symbol}","page":"Integrate","title":"Maranatha.Integrate._is_ns_rule","text":"_is_ns_rule(\n    rule::Symbol\n) -> Bool\n\nReturn true if rule is a composite exact-assembly Newton-Cotes rule symbol of the form :ns_pK.\n\nFunction description\n\nThis helper recognizes the new composite exact-rational rules introduced in this module. A rule is considered an NS rule if its symbol string begins with \"ns_p\" (e.g. :ns_p3, :ns_p5).\n\nArguments\n\nrule: Quadrature rule symbol.\n\nReturns\n\nBool: true if rule starts with \"ns_p\", else false.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate._local_nodes-Tuple{Int64, Symbol, Symbol}","page":"Integrate","title":"Maranatha.Integrate._local_nodes","text":"_local_nodes(\n    p::Int, \n    kind::Symbol, \n    which_open::Symbol\n) -> Vector{RBig}\n\nConstruct the local node positions (dimensionless u) for a Newton-Cotes block.\n\nFunction description\n\nThis helper produces the exact (rational) node locations used to solve for the local quadrature weights alpha via moment matching.\n\nFor kind == :closed, nodes are u = 0:(p-1) (length p).\nFor kind == :opened, nodes depend on the direction:\nwhich_open == :backward: u = 1:p (left-opened style)\nwhich_open == :forward : u = 0:(p-1) (right-opened style)\n\nAll nodes are returned as RBig = Rational{BigInt} to support exact assembly.\n\nArguments\n\np: Number of nodes (must satisfy p ge 2).\nkind: Either :closed or :opened.\nwhich_open: For opened blocks, either :backward or :forward.\n\nReturns\n\nVector{RBig}: Local nodes in dimensionless units.\n\nErrors\n\nThrows (via JobLoggerTools.error_benji) if p  2, kind is invalid, or which_open is not one of :backward / :forward when needed.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate._local_width-Tuple{Int64, Symbol}","page":"Integrate","title":"Maranatha.Integrate._local_width","text":"_local_width(\n    p::Int, \n    kind::Symbol\n) -> Int\n\nReturn the local block width in units of h for a Newton-Cotes block of order p.\n\nFunction description\n\nIn the exact-rational composite assembly, each local Newton-Cotes block covers a domain 0 w in dimensionless units, where w depends on whether the block is closed or opened:\n\nclosed block: w = p - 1\nopened block: w = p\n\nThis width is used to enforce the composite tiling constraint and to build the exact moment vector on 0 w.\n\nArguments\n\np: Number of nodes in the local Newton-Cotes block (must satisfy p ge 2).\nkind: Either :closed or :opened.\n\nReturns\n\nInt: The local width w in units of h.\n\nErrors\n\nThrows (via Maranatha.JobLoggerTools.error_benji) if kind is unknown.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate._parse_ns_p-Tuple{Symbol}","page":"Integrate","title":"Maranatha.Integrate._parse_ns_p","text":"_parse_ns_p(\n    rule::Symbol\n) -> Int\n\nParse the local node count p from an NS rule symbol :ns_pK.\n\nFunction description\n\nFor composite exact-assembly Newton-Cotes rules, the rule symbol encodes the local node count p as:\n\n:ns_p3, :ns_p4, :ns_p5, ...\n\nThis function extracts and validates p from the symbol.\n\nArguments\n\nrule: Quadrature rule symbol, expected to start with \"ns_p\".\n\nReturns\n\nInt: Parsed node count p (guaranteed p ge 2 if successful).\n\nErrors\n\nThrows (via Maranatha.JobLoggerTools.error_benji) if the symbol does not start with \"ns_p\" or if the parsed p is invalid.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate.integrate-NTuple{7, Any}","page":"Integrate","title":"Maranatha.Integrate.integrate","text":"integrate(\n    integrand,\n    a,\n    b,\n    N,\n    dim,\n    rule,\n    boundary\n) -> Float64\n\nEvaluate a tensor-product Newton-Cotes quadrature on the hypercube ab^textttdim.\n\nFunction description\n\nThis function serves as the unified integration dispatcher within the Maranatha.jl pipeline.\n\nIt builds the 1D nodes and weights for the selected Newton-Cotes rule on ab with resolution N.\nIt evaluates the tensor-product quadrature in dim dimensions by enumerating the multi-index over the 1D nodes and accumulating the weighted sum of textttintegrand(x_1ldotsx_textttdim).\n\nThe same bounds ab are applied along every axis, i.e. the integration domain is ab^textttdim.\n\nArguments\n\nintegrand: A callable that accepts exactly dim positional arguments (function, closure, or callable struct).\na, b: Lower/upper bounds applied to every axis.\nN: Number of subintervals per axis (rule-specific constraints apply).\ndim: Dimensionality (must satisfy dim ≥ 1).\nrule: Quadrature rule symbol (e.g. :simpson13_close, :simpson38_open, :bode_close, ...).\n\nReturns\n\nFloat64: Estimated integral value.\n\nErrors\n\nThrows an error if dim < 1.\nThrows an error if rule is unknown or if N violates rule-specific constraints.\nAny error thrown by integrand during evaluation is propagated.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate.integrate_1d-NTuple{6, Any}","page":"Integrate","title":"Maranatha.Integrate.integrate_1d","text":"integrate_1d(\n    f, \n    a, \n    b, \n    N, \n    rule,\n    boundary\n) -> Float64\n\nEvaluate the 1-dimensional integral of f(x) over a b using a tensor-product quadrature constructed from 1D nodes and weights.\n\nFunction description\n\nThis routine generates 1D quadrature nodes and weights using quadrature_1d_nodes_weights(a, b, N, rule, boundary) and computes:\n\nsum_i w_i  f(x_i) \n\nThis keeps all rule-specific constraints and behaviour centralized in quadrature_1d_nodes_weights.\n\nArguments\n\nf: Integrand callable f(x).\na, b: Integration bounds.\nN: Number of intervals (rule-specific constraints are enforced by quadrature_1d_nodes_weights).\nrule: Integration rule symbol.\nboundary: Boundary pattern symbol (:LCRC, :LORC, :LCRO, :LORO). Required for NS rules.\n\nReturns\n\nEstimated integral value as a Float64.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate.integrate_2d-NTuple{6, Any}","page":"Integrate","title":"Maranatha.Integrate.integrate_2d","text":"integrate_2d(\n    f, \n    a, \n    b, \n    N, \n    rule,\n    boundary\n) -> Float64\n\nEvaluate a 2-dimensional integral of f(x y) over the square domain a b times a b using a tensor-product quadrature constructed from 1D nodes and weights.\n\nFunction description\n\nThis routine generates 1D quadrature nodes and weights using quadrature_1d_nodes_weights(a, b, N, rule, boundary) and forms the tensor product:\n\nsum_i sum_j w_i w_j  f(x_i y_j) \n\nLoop ordering and accumulation are preserved exactly as implemented.\n\nArguments\n\nf: Integrand callable f(x, y).\na, b: Square domain bounds (used for both axes).\nN: Number of intervals per axis.\nrule: Integration rule symbol.\nboundary: Boundary pattern symbol (:LCRC, :LORC, :LCRO, :LORO). Required for NS rules.\n\nReturns\n\nEstimated integral value as a Float64.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate.integrate_3d-NTuple{6, Any}","page":"Integrate","title":"Maranatha.Integrate.integrate_3d","text":"integrate_3d(\n    f, \n    a, \n    b, \n    N, \n    rule,\n    boundary\n) -> Float64\n\nEvaluate a 3-dimensional integral of f(x y z) over the cube domain [a, b]^3 using a tensor-product quadrature constructed from 1D nodes and weights.\n\nFunction description\n\nThis routine generates 1D quadrature nodes and weights using quadrature_1d_nodes_weights(a, b, N, rule) and forms the tensor product:\n\nsum_i sum_j sum_k w_i w_j w_k  f(x_i y_j z_k) \n\nLoop ordering and accumulation are preserved exactly as implemented.\n\nArguments\n\nf: Integrand callable f(x, y, z).\na, b: Cube domain bounds (used for all axes).\nN: Number of intervals per axis.\nrule: Integration rule symbol.\nboundary: Boundary pattern symbol (:LCRC, :LORC, :LCRO, :LORO). Required for NS rules.\n\nReturns\n\nEstimated integral value as a Float64.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate.integrate_4d-NTuple{6, Any}","page":"Integrate","title":"Maranatha.Integrate.integrate_4d","text":"integrate_4d(\n    f, \n    a, \n    b, \n    N, \n    rule,\n    boundary\n) -> Float64\n\nEvaluate a 4-dimensional integral of f(x y z t) over the hypercube domain [a, b]^4 using a tensor-product quadrature constructed from 1D nodes and weights.\n\nFunction description\n\nThis routine generates 1D quadrature nodes and weights using quadrature_1d_nodes_weights(a, b, N, rule, boundary) and forms the tensor product:\n\nsum_i sum_j sum_k sum_ell w_i w_j w_k w_ell  f(x_i y_j z_k t_ell) \n\nLoop ordering and accumulation are preserved exactly as implemented.\n\nArguments\n\nf: Integrand callable f(x, y, z, t).\na, b: Hypercube domain bounds (used for all axes).\nN: Number of intervals per axis.\nrule: Integration rule symbol.\nboundary: Boundary pattern symbol (:LCRC, :LORC, :LCRO, :LORO). Required for NS rules.\n\nReturns\n\nEstimated integral value as a Float64.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate.integrate_nd-NTuple{6, Any}","page":"Integrate","title":"Maranatha.Integrate.integrate_nd","text":"integrate_nd(\n    f,\n    a,\n    b,\n    N,\n    rule,\n    boundary;\n    dim::Int\n) -> Float64\n\nPerform an multidimensional tensor-product quadrature over the hypercube domain ab^textttdim using a 1D rule specified by rule.\n\nFunction description\n\nThis routine evaluates a multidimensional integral by constructing the tensor product of a 1D quadrature rule.\n\nThe algorithm:\n\nBuilds 1D quadrature nodes and weights (xs, ws) via quadrature_1d_nodes_weights(a, b, N, rule, boundary).\nIterates over all multi-indices (i_1 i_2 ldots i_textttdim) using an odometer-style index update.\nForms the tensor-product weight\nw =  textttwstexttti_texttt1texttt ast textttwstexttti_texttt2texttt ast ldots ast  textttwstexttti_textttdimtexttt.\nEvaluates the integrand as\nftexttt( textttxstexttti_texttt1texttt textttxstexttti_texttt2texttt ldots textttxstexttti_textttdimtexttt texttt) \nAccumulates the weighted sum\ndisplaystylesum_i_1ldotsi_textttdim w ast ftexttt(ldotstexttt).\n\nThis implementation intentionally mirrors the explicit loop ordering and accumulation style used throughout the Maranatha.jl quadrature stack to ensure reproducibility and consistent floating-point behavior.\n\nArguments\n\nf: Integrand callable accepting dim scalar arguments.\na, b: Domain bounds defining the hypercube ab^textttdim.\nN: Number of subdivisions per axis used to build the 1D rule.\nrule: Integration rule symbol (e.g., :simpson13_close, :bode_open, etc.).\nboundary: Boundary pattern symbol (:LCRC, :LORC, :LCRO, :LORO). Required for NS rules.\ndim: Number of dimensions (must satisfy dimge 1).\n\nReturns\n\nFloat64: Numerical quadrature estimate of the integral.\n\nNotes\n\nThis is a pure tensor-product construction; computational cost scales as O(textttlength(xs)^textttdim) and therefore grows exponentially with dim.\nRule-specific constraints on N are enforced inside quadrature_1d_nodes_weights.\nThe integrand is called as f(x_1 x_2 ldots x_textttdim) using splatting.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate.quadrature_1d_nodes_weights-Tuple{Real, Real, Int64, Symbol, Symbol}","page":"Integrate","title":"Maranatha.Integrate.quadrature_1d_nodes_weights","text":"quadrature_1d_nodes_weights(\n    a::Real, \n    b::Real, \n    N::Int, \n    rule::Symbol, \n    boundary::Symbol\n) -> (xs, ws)\n\nConstruct 1-dimensional quadrature nodes and weights on a b for composite Newton-Cotes rules.\n\nFunction description\n\nThis function is the public 1-dimensional node/weight generator used by the integration dispatchers.\n\nIt supports:\n\nComposite exact-assembly rules :ns_pK\n\nIf rule is recognized as an NS rule, this routine:\n\nParses p from rule,\nBuilds (or fetches) the coefficient vector β for (p, boundary, N),\nForms nodes textttxs_j = a + j  h for j = 0  ldots  N,\nForms weights textttws_j = beta_j  h, where displaystyleh = fracb-aN.\n\nThe return types are Vector{Float64} for both nodes and weights.\n\nArguments\n\na, b: Lower/upper bounds of the 1D interval.\nN: Number of subintervals (must satisfy N ge 1 and composite constraints for the selected boundary).\nrule: Rule symbol. Supported:\nNew rules: :ns_p3, :ns_p4, :ns_p5, ...\nboundary: Boundary pattern symbol (:LCRC, :LORC, :LCRO, :LORO). Required for NS rules.\n\nReturns\n\nxs::Vector{Float64}: Nodes of length N+1.\nws::Vector{Float64}: Weights of length N+1.\n\nErrors\n\nThrows ArgumentError if N  1.\nThrows (via Maranatha.JobLoggerTools.error_benji) if boundary is invalid, if the composite constraint fails, or if rule is unsupported.\n\nNotes\n\nThis function currently errors on non-NS rules unless you extend the fallback branch with your pre-existing implementation.\n\n\n\n\n\n","category":"method"},{"location":"lib/PlotTools/#Maranatha.PlotTools","page":"PlotTools","title":"Maranatha.PlotTools","text":"","category":"section"},{"location":"lib/PlotTools/#Maranatha.PlotTools.plot_convergence_result-Tuple{Real, Real, String, Vector{Float64}, Vector{Float64}, Vector{Float64}, Any}","page":"PlotTools","title":"Maranatha.PlotTools.plot_convergence_result","text":"plot_convergence_result(\n    a::Real,\n    b::Real,\n    name::String,\n    hs::Vector{Float64},\n    estimates::Vector{Float64},\n    errors::Vector{Float64},\n    fit_result;\n    rule::Symbol = :ns_p3,\n    boundary::Symbol = :LCRC\n) -> Nothing\n\nPlot convergence data I(h) against h^2, overlay the fitted extrapolation curve, and visualize a fit uncertainty band propagated from the parameter covariance.\n\nFunction description\n\nThis routine is a visualization companion to Maranatha.LeastChiSquareFit.least_chi_square_fit. It produces a publication-style convergence plot and saves it as a PNG file.\n\nThe x-axis is h^2 (with displaystyleh = fracb-aN supplied via hs), and the y-axis is the raw quadrature estimate I(h) with pointwise error bars (absolute values are used for plotting).\n\nAlthough the x-axis is plotted in h^2, the fitted model is evaluated as a function of h. Internally, the routine builds a dense grid in h^2, converts it via h = sqrth^2, and then evaluates the model and its propagated uncertainty on that h grid.\n\nModel reconstruction (no refitting)\n\nThis function does not refit anything. It uses the stored fit output:\n\npvec = fit_result.params\nCov  = fit_result.cov\nI0   = fit_result.estimate\nI0_err = fit_result.estimate_error\n\nA convergence model is reconstructed from the fit parameters:\n\nI(h) = sum_texttti=1^n lambda_texttti  h^textttpowersi\n\nwhere powers is the exponent vector determined during fitting and stored in fit_result.powers.\n\nThe exponent structure used for plotting is taken directly from fit_result.powers, ensuring consistency with the model used in Maranatha.LeastChiSquareFit.least_chi_square_fit.\n\nThis routine assumes that fit_result.powers corresponds to the same basis ordering as fit_result.params. If this field is missing or inconsistent, the model reconstruction will be invalid.\n\nFit curve and uncertainty band\n\nFor each point on a dense grid in h, the basis vector is constructed using the exact exponent set employed in the fit.\n\nLet powers denote the exponent vector stored in fit_result.powers (with powers[1] = 0 for the constant term). Then\n\nvarphi_1(h) = 1 qquad\nvarphi_texttti(h) = h^textttpowersi quad (texttti = 2 ldots n)\n\nwhere n = length(fit_result.params).\n\nThe routine evaluates:\n\nfit curve: I_textfit(h) = bmlambda^mathsfT varphi(h)\n1sigma fit uncertainty:\n\nsigma_textfit(h)^2 = varphi(h)^mathsfT  V  varphi(h)\n\nwhere V is fit_result.cov.\n\nThe plotted shaded band corresponds to I_textfit(h) pm sigma_textfit(h) and therefore includes parameter correlations.\n\nPlot elements\n\nThe resulting figure contains:\n\nthe fitted curve I_textfit(h) (line),\nthe fit uncertainty band pm sigma (shaded region),\nthe measured points with error bars,\nthe extrapolated point at h^2 = 0 with uncertainty fit_result.estimate_error.\n\nOutput\n\nThe output file is saved as:\n\nconvergence_$(name)_$(rule)_$(boundary).png\n\nArguments\n\na, b: Integration bounds used only to derive a representative subdivision count Nref from the smallest step size in hs.\nname: Label used in the output filename.\nhs: Step sizes h (typically displaystyleh = fracb-aN).\nestimates: Quadrature estimates I(h) corresponding to hs.\nerrors: Error estimates for I(h) (absolute values are used for plotting).\nfit_result: Fit object expected to provide:\nfit_result.params\nfit_result.cov\nfit_result.estimate\nfit_result.estimate_error\n\nKeyword arguments\n\nrule: Quadrature rule symbol (used for residual-based p detection and labeling).\nboundary: Boundary pattern symbol (used for residual-based p detection and labeling).\n\nReturns\n\nnothing.\n\nErrors\n\nThrows an error if input lengths mismatch.\nThrows an error if no valid points remain after filtering.\nThrows an error if fit_result.powers is missing or inconsistent with fit_result.params (basis length/order mismatch).\nPropagates errors from downstream plotting and linear-algebra operations (e.g. non-finite values after filtering, covariance not usable for propagation).\n\n\n\n\n\n","category":"method"},{"location":"lib/PlotTools/#Maranatha.PlotTools.set_pyplot_latex_style","page":"PlotTools","title":"Maranatha.PlotTools.set_pyplot_latex_style","text":"set_pyplot_latex_style(\n    scale::Float64=0.5\n) -> Nothing\n\nConfigure PyPlot.jl with LaTeX rendering and appropriate font settings for publications.\n\nThis function modifies matplotlib.rcParams to enable LaTeX-based text rendering and adjust  font sizes, marker sizes, and line widths for consistent visual output.   Useful for generating high-quality plots for papers or presentations.\n\nArguments\n\nscale::Float64: Scaling factor for font sizes and figure dimensions. Default is 0.5.\n\nSide Effects\n\nModifies PyPlot.jl's global rendering configuration via matplotlib.rcParams.\n\n\n\n\n\n","category":"function"},{"location":"lib/JobLoggerTools/#Maranatha.JobLoggerTools","page":"JobLoggerTools","title":"Maranatha.JobLoggerTools","text":"","category":"section"},{"location":"lib/JobLoggerTools/#Maranatha.JobLoggerTools.assert_benji","page":"JobLoggerTools","title":"Maranatha.JobLoggerTools.assert_benji","text":"assert_benji(\n    cond::Bool, \n    msg::AbstractString, \n    jobid::Union{Nothing, String}=nothing\n) -> Nothing\n\nAssert that cond is true. If false, log an error with timestamp and job ID, then throw.\n\nArguments\n\ncond: Boolean condition to assert.\nmsg: Message to print if assertion fails.\njobid: Optional job identifier.\n\n\n\n\n\n","category":"function"},{"location":"lib/JobLoggerTools/#Maranatha.JobLoggerTools.debug_benji","page":"JobLoggerTools","title":"Maranatha.JobLoggerTools.debug_benji","text":"debug_benji(\n    msg::AbstractString, \n    jobid::Union{Nothing, String}=nothing\n) -> Nothing\n\nPrint a timestamped debug message with optional job ID.\n\nThe message is prefixed with [DEBUG], and flushed to stdout.\n\nArguments\n\nmsg: Debug message to print.\njobid: Optional job identifier.\n\n\n\n\n\n","category":"function"},{"location":"lib/JobLoggerTools/#Maranatha.JobLoggerTools.error_benji","page":"JobLoggerTools","title":"Maranatha.JobLoggerTools.error_benji","text":"error_benji(\n    msg::AbstractString, \n    jobid::Union{Nothing, String}=nothing\n) -> Nothing\n\nPrint an error message with timestamp and job ID (if given), then throw an error with the same message.\n\nAlso flushes stdout and stderr after printing.\n\n\n\n\n\n","category":"function"},{"location":"lib/JobLoggerTools/#Maranatha.JobLoggerTools.info_benji","page":"JobLoggerTools","title":"Maranatha.JobLoggerTools.info_benji","text":"info_benji(\n    msg::AbstractString, \n    jobid::Union{Nothing, String}=nothing\n) -> Nothing\n\nPrint a timestamped informational message with optional job ID.\n\nThe message is prefixed with [INFO], and flushed to stdout.\n\nArguments\n\nmsg: Informational message to print.\njobid: Optional job identifier.\n\n\n\n\n\n","category":"function"},{"location":"lib/JobLoggerTools/#Maranatha.JobLoggerTools.log_stage_benji","page":"JobLoggerTools","title":"Maranatha.JobLoggerTools.log_stage_benji","text":"log_stage_benji(\n    title::String, \n    jobid::Union{Nothing, String}=nothing\n) -> Nothing\n\nPrint a high-level stage delimiter with a title, surrounded by = lines.\n\nUseful for separating major processing stages in logs.\n\n\n\n\n\n","category":"function"},{"location":"lib/JobLoggerTools/#Maranatha.JobLoggerTools.log_stage_sub1_benji","page":"JobLoggerTools","title":"Maranatha.JobLoggerTools.log_stage_sub1_benji","text":"log_stage_sub1_benji(\n    title::String, \n    jobid::Union{Nothing, String}=nothing\n) -> Nothing\n\nPrint a substage delimiter with a title, surrounded by - lines.\n\nUsed for visually marking sub-sections in logs.\n\n\n\n\n\n","category":"function"},{"location":"lib/JobLoggerTools/#Maranatha.JobLoggerTools.println_benji","page":"JobLoggerTools","title":"Maranatha.JobLoggerTools.println_benji","text":"println_benji(\n    msg::AbstractString, \n    jobid::Union{Nothing, String}=nothing\n) -> Nothing\n\nPrint a timestamped log message with optional job ID.\n\nArguments\n\nmsg: The message to print.\njobid: Optional job identifier to prepend.\n\nOutput is printed to stdout, immediately flushed.\n\n\n\n\n\n","category":"function"},{"location":"lib/JobLoggerTools/#Maranatha.JobLoggerTools.warn_benji","page":"JobLoggerTools","title":"Maranatha.JobLoggerTools.warn_benji","text":"warn_benji(\n    msg::AbstractString, \n    jobid::Union{Nothing, String}=nothing\n) -> Nothing\n\nPrint a timestamped warning message with optional job ID.\n\nThe message is prefixed with [WARNING], and flushed to stdout.\n\nArguments\n\nmsg: Warning message to print.\njobid: Optional job identifier.\n\n\n\n\n\n","category":"function"},{"location":"lib/JobLoggerTools/#Maranatha.JobLoggerTools.@logtime_benji-Tuple{Any, Any}","page":"JobLoggerTools","title":"Maranatha.JobLoggerTools.@logtime_benji","text":"@logtime_benji(\n    jobid_expr, \n    expr\n) -> Any\n\nMacro that times and logs the execution of an expression, with optional GC allocation info.\n\nArguments\n\njobid_expr: Optional job ID (can be nothing).\nexpr: Any Julia expression to execute and time.\n\nLogs elapsed time and memory usage with a timestamp. Returns the value of expr.\n\n\n\n\n\n","category":"macro"},{"location":"lib/Runner/#Maranatha.Runner","page":"Runner","title":"Maranatha.Runner","text":"","category":"section"},{"location":"lib/Runner/#Maranatha.Runner.run_Maranatha-Tuple{Any, Any, Any}","page":"Runner","title":"Maranatha.Runner.run_Maranatha","text":"run_Maranatha(\n    integrand,\n    a,\n    b;\n    dim::Int = 1,\n    nsamples = [4, 8, 16],\n    rule::Symbol = :ns_p3,\n    boundary::Symbol = :LCRC,\n    err_method::Symbol = :derivative,\n    fit_terms::Int = 2\n)\n\nHigh-level execution pipeline for n-dimensional quadrature, error modeling, and convergence extrapolation.\n\nFunction description\n\nrun_Maranatha is the orchestration entry point that combines the core subsystems of Maranatha:\n\nMaranatha.Integrate      : tensor-product Newton-Cotes quadrature in arbitrary dimension\nMaranatha.ErrorEstimator : derivative-based error scale models\nMaranatha.LeastChiSquareFit : least-chi^2 fitting for h to 0 extrapolation\n\nFor each resolution N in nsamples, the runner performs:\n\nCompute step size\nh = fracb-aN  \nEvaluate the integral using the selected rule via Maranatha.Integrate.integrate.\nEstimate the integration error according to err_method.\nAccumulate (h, estimate, error) triplets.\n\nAfter processing all resolutions, a weighted convergence fit is performed using a residual-informed exponent basis (derived from the composite Newton–Cotes midpoint residual model):\n\nI(h) = sum_texttti=1^n lambda_texttti  h^textttpowersi \n\nwhere the exponent vector powers is determined during fitting and stored in the fit result (e.g. fit_result.powers, with powers[1] = 0 for the constant term).\n\nThe final extrapolated estimate lambda_0 is returned together with the full fit object and the raw data vectors used in the fit.\n\nArguments\n\nintegrand: Callable integrand. May be a function, closure, or callable struct. Must accept dim scalar positional arguments.\na, b: Scalar bounds defining the hypercube domain ab^n where n is (spacetime) dimensionality.\n\nKeyword arguments\n\ndim::Int=1: Dimensionality of the tensor-product quadrature. Internally dispatched through Maranatha.Integrate.integrate,  which supports specialized implementations (from 1-dimensional to 4-dimensional quadrature) and a general n-dimensional quadrature fallback.\nnsamples=[4,8,16]: Vector of subdivision counts N. Each value defines a different grid resolution used in the convergence study.\nrule::Symbol = :ns_p3: Newton–Cotes rule identifier. For the Taylor/moment-based general rules, use :ns_pK (e.g. :ns_p3, :ns_p4, :ns_p5, ...). This symbol is forwarded to both integration and error-estimation modules.\nboundary::Symbol = :LCRC: Boundary pattern for the composite rule assembly. Supported values are: :LCRC, :LORC, :LCRO, :LORO. This is forwarded consistently to integration, error estimation, and fitting.\nerr_method::Symbol=:derivative: Error estimation strategy. Supported values:\n:derivative  → Maranatha.ErrorEstimator.estimate_error\nfit_terms::Int = 2: Number of basis terms used in the convergence model (including the constant term). This is forwarded as nterms to the least-chi^2 fitter, which determines the first nterms-1 nonzero residual-derived exponents and stores them in fit_result.powers.\n\nReturns\n\nA 3-tuple:\n\nfinal_estimate::Float64: Convenience alias for fit_result.estimate.\nfit_result::NamedTuple: Fit object returned by Maranatha.LeastChiSquareFit.least_chi_square_fit.   Fields:\nestimate::Float64 : Extrapolated integral estimate I_0 (the h to 0 limit), equal to params[1].\nestimate_error::Float64 : 1  sigma uncertainty of estimate, taken as param_errors[1] from the covariance diagonal.\nparams::Vector{Float64} : Fitted parameter vector lambda_1 lambda_2 ldots corresponding to the model displaystyleI(h) = sum_texttti=1^n lambda_texttti  h^textttpowersi where the exponent vector is stored in fit_result.powers.\nparam_errors::Vector{Float64} : 1  sigma uncertainties for params (square roots of diag(cov)).\ncov::Matrix{Float64} : Parameter covariance matrix, suitable for uncertainty propagation (e.g. sigma_mathrmfit(h)^2 = phi(h)^topVphi(h) where V is covariance matrix).\npowers::Vector{Int} : Exponent vector used in the fit basis (typically with powers[1] = 0 for the constant term). This ensures plotting and downstream reconstruction use the exact same model as the fit.\nchisq::Float64 : Total chi-square value \nchi^2 = sum_i left(fracy_i - hat y_isigma_iright)^2 \nredchisq::Float64 : Reduced chi-square chi^2mathrmdof. (If dof == 0, this may be Inf/NaN depending on chisq.)\ndof::Int : Degrees of freedom length(estimates) - length(params).\ndata::NamedTuple: Raw convergence data:\nh   : step sizes\navg : integral estimates\nerr : error estimates\n\nDesign notes\n\nThe runner is dimension-agnostic: the tensor-product implementation allows arbitrary n ge 1 (n: dimension), subject only to computational cost.\nError estimators provide a scale model rather than a strict truncation bound, enabling stable weighted fits across dimensions.\nLogging and timing are fully centralized through Maranatha.JobLoggerTools.\n\nExample\n\nf(x, y, z, t) = sin(x * y^3 * z * t) * exp(x^2)\n\nI0, fit, data = run_Maranatha(\n    f, \n    0.0, 1.0;\n    dim=4,\n    nsamples=[40, 44, 48, 52, 56, 60, 64],\n    rule = :ns_p5,\n    boundary = :LCRC,\n    err_method=:derivative\n    fit_terms=4\n)\n\n\n\n\n\n","category":"method"},{"location":"lib/Z_q/#Maranatha.Z_q","page":"Z_q","title":"Maranatha.Z_q","text":"","category":"section"},{"location":"lib/Integrands/#Maranatha.Integrands","page":"Integrands","title":"Maranatha.Integrands","text":"","category":"section"},{"location":"lib/Integrands/#Maranatha.Integrands.available_integrands-Tuple{}","page":"Integrands","title":"Maranatha.Integrands.available_integrands","text":"available_integrands()\n\nReturn the list of currently registered integrand names.\n\nReturns\n\nVector{Symbol}: Registered integrand keys.\n\nNotes\n\nThe order of the returned symbols follows the iteration order of the internal dictionary and is not guaranteed to be stable across Julia versions.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrands/#Maranatha.Integrands.integrand-Tuple{Symbol}","page":"Integrands","title":"Maranatha.Integrands.integrand","text":"integrand(\n    name::Symbol; \n    kwargs...\n)\n\nConstruct a callable integrand from the registry.\n\nFunction description\n\nThis function looks up name in the integrand registry and invokes the corresponding factory with the provided keyword arguments. The result is a callable object that can be passed directly into Maranatha.Runner.run_Maranatha.\n\nArguments\n\nname::Symbol: Integrand identifier registered via register_integrand!.\n\nKeyword arguments\n\nkwargs...: Keyword arguments forwarded to the registered factory.\n\nReturns\n\nA callable integrand object returned by the registered factory.\n\nErrors\n\nThrows an error if name is not registered.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrands/#Maranatha.Integrands.register_integrand!-Tuple{Symbol, Function}","page":"Integrands","title":"Maranatha.Integrands.register_integrand!","text":"register_integrand!(\n    name::Symbol, \n    factory::Function\n)\n\nRegister a new integrand factory into the Maranatha.jl integrand registry.\n\nFunction description\n\nThis function associates an integrand name name with a factory function factory. The factory must accept keyword arguments and return a callable integrand object (e.g., a closure or a callable struct).\n\nOnce registered, the integrand can be constructed via:\n\nintegrand(name; kwargs...).\n\nArguments\n\nname::Symbol: Integrand identifier used as the registry key.\nfactory::Function: Factory function of the form factory(; kwargs...) -> f, where f is callable.\n\nReturns\n\nnothing\n\nNotes\n\nRe-registering an existing name overwrites the prior factory.\nThe registry is stored as a module-level constant dictionary to keep lookup/dispatch lightweight.\n\n\n\n\n\n","category":"method"},{"location":"man/Maranatha/#Maranatha-Module","page":"Maranatha Module","title":"Maranatha Module","text":"To be updated.","category":"section"},{"location":"lib/F0000GammaEminus1/#Maranatha.F0000GammaEminus1","page":"F0000GammaEminus1","title":"Maranatha.F0000GammaEminus1","text":"","category":"section"},{"location":"lib/F0000GammaEminus1/#Maranatha.F0000GammaEminus1.exI0_safe-Tuple{T} where T<:Number","page":"F0000GammaEminus1","title":"Maranatha.F0000GammaEminus1.exI0_safe","text":"exI0_safe(\n    x::T\n) where {T<:Number}\n\nCompute exp(-x) * I0(x) (modified Bessel I0) in an overflow-safe manner.\n\nFunction description\n\nThis helper evaluates the scaled Bessel factor exp(-x) * besseli(0, x) that appears in the F0000 integrand.\n\nFor small to moderate x, it computes the expression directly.\nFor large x, it switches to an asymptotic series for exp(-x) I0(x) to avoid overflow in besseli(0, x) while preserving the intended scaling.\n\nArguments\n\nx::T: Input value (intended usage: x ≥ 0).\n\nReturns\n\nT: The value of exp(-x) * I0(x).\n\nNotes\n\nThe branch threshold x ≤ 50 is a Float64-oriented \"safe zone\" heuristic and is kept identical to the original implementation for reproducibility.\nThe asymptotic series used is: exp(-x) I0(x) ≈ 1/sqrt(2πx) * (1 + 1/(8x) + 9/(128x^2) + 225/(3072x^3) + 11025/(98304x^4)). This is a truncated large-x expansion and is not a strict error bound.\nThe implementation is written to accept generic Number inputs so it can work with AD / Taylor objects when needed.\n\nErrors\n\nNo explicit domain checks are performed. If x is negative, the asymptotic branch is not mathematically intended and may produce complex values due to the square root.\n\n\n\n\n\n","category":"method"},{"location":"lib/F0000GammaEminus1/#Maranatha.F0000GammaEminus1.g_F0000_raw-Tuple{T} where T<:Number","page":"F0000GammaEminus1","title":"Maranatha.F0000GammaEminus1.g_F0000_raw","text":"g_F0000_raw(\n    y::T\n) where {T<:Number}\n\nEvaluate the raw integrand g_F0000_raw(y) used in the F0000 computation for y ∈ (0, 1).\n\nFunction description\n\nThis function maps\n\nx = (1 - y) / y  (so x > 0 for 0 < y < 1),\n\nthen forms the raw integrand as the sum of two pieces:\n\ntermA: proportional to (exp(-x) I0(x))^4 with a rational prefactor in y,\ntermB: a correction term involving exp(-x/2) and a rational prefactor in y.\n\nThe algebraic form is preserved exactly from the original implementation.\n\nArguments\n\ny::T: Real input (intended usage: 0 < y < 1).\n\nReturns\n\nT: Raw integrand value at y.\n\nNotes\n\nThis raw form contains endpoint-singular prefactors such as 1/y^3 and 1/(y*(1-y)). It is therefore intended to be evaluated away from y = 0, 1. Endpoint suppression / regularization is handled in gtilde_F0000 via the t-space cutoff.\nThe implementation accepts generic Number to support AD / Taylor fallbacks.\n\nErrors\n\nNo explicit domain checks are performed. Passing y ≤ 0 or y ≥ 1 can lead to division by zero or non-finite values.\n\n\n\n\n\n","category":"method"},{"location":"lib/F0000GammaEminus1/#Maranatha.F0000GammaEminus1.gtilde_F0000-Tuple{T} where T<:Number","page":"F0000GammaEminus1","title":"Maranatha.F0000GammaEminus1.gtilde_F0000","text":"gtilde_F0000(\n    t::T; \n    p::Int=2, \n    eps::T=T(1e-15)\n) where {T<:Number}\n\nReturn the transformed integrand g̃(t) for the F0000 integral after the variable substitution y = t^p on the interval t ∈ [0, 1].\n\nFunction description\n\nThis routine wraps g_F0000_raw(y) by applying:\n\nsubstitution: y = t^p with integer p ≥ 1,\nJacobian: dy = p * t^(p-1) dt,\n\nso the returned transformed integrand is:\n\ng̃(t) = p * t^(p-1) * g_F0000_raw(t^p).\n\nTo avoid endpoint singularities inherited from the raw y-integrand, the function returns 0 when t is within eps of either endpoint.\n\nArguments\n\nt::T: Parameter in [0, 1].\n\nKeyword arguments\n\np::Int=2: Power used in the substitution y = t^p.\neps::T=T(1e-15): Endpoint cutoff. If t ≤ eps or 1 - t ≤ eps, returns 0.\n\nReturns\n\nT: The transformed integrand value g̃(t) (or zero near endpoints).\n\nNotes\n\nEndpoint suppression is implemented exactly (hard cutoff) to keep numerical behavior unchanged and to avoid non-finite weights in quadrature rules that sample near t = 0 or t = 1.\nThe function is generic in T<:Number so it can be used with AD / Taylor objects, but the cutoff comparisons (t ≤ eps) require an ordered type; this is intended for real-valued t.\n\nErrors\n\nThrows an error if p < 1 (implicitly, via t^(p-1) or user intent); no explicit check is performed here to preserve original behavior.\n\n\n\n\n\n","category":"method"},{"location":"lib/AvgErrFormatter/#Maranatha.AvgErrFormatter","page":"AvgErrFormatter","title":"Maranatha.AvgErrFormatter","text":"","category":"section"},{"location":"lib/AvgErrFormatter/#Maranatha.AvgErrFormatter.avgerr_e2d-Tuple{String, String}","page":"AvgErrFormatter","title":"Maranatha.AvgErrFormatter.avgerr_e2d","text":"avgerr_e2d(\n    censtr::String, \n    errstr::String\n) -> String\n\nFormat a central value and its error into a compact string using parenthetical pm notation.\n\nThis function takes the central value and error as strings in scientific notation (e.g., \"1.234e+01\", \"3.2e-01\"),  and returns a formatted string such as \"12.3(3)\". It handles different scales and adds a * suffix if the error dominates.\n\nArguments\n\ncenstr::String : Central value string in scientific notation.\nerrstr::String : Error value string in scientific notation.\n\nReturns\n\nString : Formatted result like \"1.23(45)\" or \"1.2(3) *\" depending on magnitude and dominance.\n\n\n\n\n\n","category":"method"},{"location":"lib/AvgErrFormatter/#Maranatha.AvgErrFormatter.avgerr_e2d_from_float-Tuple{Float64, Float64}","page":"AvgErrFormatter","title":"Maranatha.AvgErrFormatter.avgerr_e2d_from_float","text":"avgerr_e2d_from_float(\n    cen::Float64, \n    err::Float64\n) -> String\n\nConvert a central value and its error from Float64 into a compact exponential pm string.\n\nThis is a wrapper for avgerr_e2d that takes float inputs and internally converts them to scientific notation strings with high precision before formatting.\n\nArguments\n\ncen::Float64 : Central value.\nerr::Float64 : Error value.\n\nReturns\n\nString : Formatted output like \"1.23(4)e+02\" or \"1.2(3) *\".\n\n\n\n\n\n","category":"method"},{"location":"lib/AvgErrFormatter/#Maranatha.AvgErrFormatter.round_sig","page":"AvgErrFormatter","title":"Maranatha.AvgErrFormatter.round_sig","text":"round_sig(\n    x::Float64, \n    sig::Int=2\n) -> Float64\n\nRound a number to a specified number of significant digits.\n\nArguments\n\nx::Float64  : Number to round.\nsig::Int=2  : Number of significant digits (default: 2).\n\nReturns\n\nFloat64 : The number rounded to the specified significant digits.\n\n\n\n\n\n","category":"function"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator","text":"","category":"section"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator._leading_midpoint_residual_term-Tuple{Symbol, Symbol, Int64}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator._leading_midpoint_residual_term","text":"_leading_midpoint_residual_term(\n    rule::Symbol,\n    boundary::Symbol,\n    Nsub::Int;\n    kmax::Int = 64\n) -> Tuple{Int, Integrate.RBig}\n\nBuild exact composite weights for (rule, boundary, Nsub) and extract the leading midpoint residual term.\n\nFunction description\n\nThis helper is a convenience wrapper around Maranatha.Integrate._assemble_composite_beta_rational and _leading_midpoint_residual_term_from_beta.\n\nWorkflow:\n\nValidate boundary via Maranatha.Integrate._decode_boundary.\nRequire rule to be of NS form :ns_pK (midpoint residual model is defined for these).\nParse p from rule and assemble the exact rational beta.\nScan for the first nonzero midpoint residual term (k, coeff).\n\nArguments\n\nrule: Must be an :ns_pK-style rule symbol (e.g. :ns_p3, :ns_p5).\nboundary: Boundary pattern (:LCRC, :LORC, :LCRO, :LORO).\nNsub: Number of subintervals (must satisfy the composite tiling constraint for that boundary).\nkmax: Maximum k to scan.\n\nReturns\n\n(k, coeff): The leading nonzero residual order and its exact coefficient.\n\nErrors\n\nThrows (via Maranatha.JobLoggerTools.error_benji) if boundary is invalid, if rule is not :ns_pK, if Nsub is invalid for the boundary tiling, or if no term is found up to kmax.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator._leading_midpoint_residual_term_from_beta-Tuple{Vector{Rational{BigInt}}, Int64}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator._leading_midpoint_residual_term_from_beta","text":"_leading_midpoint_residual_term_from_beta(\n    β::Vector{Integrate.RBig},\n    Nsub::Int;\n    kmax::Int = 64\n) -> Tuple{Int, Integrate.RBig}\n\nFind the first nonzero midpoint residual term (k, coeff) from exact composite weights beta.\n\nFunction description\n\nThis helper scans the midpoint-centered residual expansion induced by a composite Newton-Cotes rule assembled on the integer u-grid j = 0  ldots  N_textsub:\n\nCenter (dimensionless): displaystylec = fracN_textsub2\nResidual moment for each k:\n\ntexttttextttdiff_k = intlimits_0^N_textsub du  left( u - c right)^k - sum_j=0^N_textsub beta_j  left( j - c right)^k \n\nTaylor coefficient (exact rational):\n\ntextttcoeff_k = fractextttdiff_kk\n\nThe function returns the first k (starting from k=0) for which textttdiff_k neq 0, together with its exact rational coefficient textttcoeff_k.\n\nThis is intended to identify the leading midpoint residual order used by the midpoint-based convergence/error heuristics.\n\nArguments\n\nβ: Exact rational composite coefficient vector beta (length N_textsub + 1), typically produced by Maranatha.Integrate._assemble_composite_beta_rational. The entry β[j+1] corresponds to node j.\nNsub: Number of subintervals defining the u-grid 0 ldots N_textsub.\nkmax: Maximum derivative order k to scan (inclusive).\n\nReturns\n\nk::Int: The first order with nonzero residual moment.\ncoeff::Integrate.RBig: The exact rational Taylor coefficient displaystylefractextttdiff_kk.\n\nErrors\n\nThrows (via Maranatha.JobLoggerTools.error_benji) if kmax < 0.\nThrows if no nonzero residual is found up to kmax.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator._leading_midpoint_residual_terms-Tuple{Symbol, Symbol, Int64}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator._leading_midpoint_residual_terms","text":"_leading_midpoint_residual_terms(\n    rule::Symbol,\n    boundary::Symbol,\n    Nsub::Int;\n    nterms::Int = 2,\n    kmax::Int = 128\n) -> Tuple{Vector{Int}, Vector{Integrate.RBig}}\n\nBuild exact composite weights for (rule, boundary, Nsub) and collect the first nterms midpoint residual terms.\n\nFunction description\n\nThis helper is the public-facing (within ErrorEstimator) convenience wrapper for midpoint residual extraction.\n\nWorkflow:\n\nValidate boundary via Maranatha.Integrate._decode_boundary (catches typos early).\nRequire rule to be an NS rule (:ns_pK) because the residual/beta construction is defined in terms of the exact-rational NS assembly.\nParse p from rule.\nAssemble exact rational composite coefficients βR using Maranatha.Integrate._assemble_composite_beta_rational(p, boundary, Nsub).\nExtract the first nterms nonzero midpoint residual pairs (k, coeff) via _leading_midpoint_residual_terms_from_beta.\n\nArguments\n\nrule: Must be an :ns_pK rule symbol.\nboundary: Boundary pattern (:LCRC, :LORC, :LCRO, :LORO).\nNsub: Number of subintervals for the composite rule.\nnterms: Number of nonzero residual terms to collect (must satisfy nterms ≥ 1).\nkmax: Maximum derivative order scanned (inclusive, must satisfy kmax ≥ 0).\n\nReturns\n\nks::Vector{Int}: First nterms nonzero residual orders.\ncoeffs::Vector{Integrate.RBig}: Exact rational coefficients displaystylefractextttdiff_kk diff(k)/k! aligned with ks.\n\nErrors\n\nThrows (via Maranatha.JobLoggerTools.error_benji) if boundary is invalid, if rule is not :ns_pK, if Nsub violates composite constraints, or if insufficient nonzero terms exist up to kmax.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator._leading_midpoint_residual_terms_from_beta-Tuple{Vector{Rational{BigInt}}, Int64}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator._leading_midpoint_residual_terms_from_beta","text":"_leading_midpoint_residual_terms_from_beta(\n    β::Vector{Integrate.RBig},\n    Nsub::Int;\n    nterms::Int = 2,\n    kmax::Int = 128\n) -> Tuple{Vector{Int}, Vector{Integrate.RBig}}\n\nCollect the first nterms nonzero midpoint residual terms (k, coeff) from exact weights beta.\n\nFunction description\n\nThis routine generalizes _leading_midpoint_residual_term_from_beta by collecting multiple nonzero residual terms.\n\nFor each k = 0  ldots  k_max, it computes:\n\nCenter: displaystylec = fracN_textsub2 \nExact moment:\n\ntextttexact_k = intlimits_0^N_textsub du  left( u - c right)^k\n\nQuadrature moment:\n\ntextttapprox_k = sum_0^N_textsub beta_j  left( j - c right)^k\n\nResidual and Taylor coefficient:\n\ntextttdiff_k = textttexact_k - textttapprox_k\n\ntextttcoeff_k = fractextttdiff_kk\n\nWhenever textttdiff_k neq 0, the pair (k, coeff(k)) is appended. The function stops once nterms pairs have been collected.\n\nAll outputs remain in exact rational arithmetic (Maranatha.Integrate.RBig).\n\nArguments\n\nβ: Exact rational coefficient vector of length N_textsub + 1 (index β[j+1] corresponds to node j).\nNsub: Number of subintervals defining the u-grid 0  ldots  N_textsub.\nnterms: Number of nonzero terms to collect (must satisfy nterms ≥ 1).\nkmax: Maximum k to scan (inclusive, must satisfy kmax ≥ 0).\n\nReturns\n\nks::Vector{Int}: Collected residual orders k (ascending by scan).\ncoeffs::Vector{Integrate.RBig}: Exact Taylor coefficients diff(k)/k!, aligned with ks.\n\nErrors\n\nThrows (via Maranatha.JobLoggerTools.error_benji) if nterms < 1 or kmax < 0.\nThrows if fewer than nterms nonzero terms exist up to kmax.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator._leading_residual_ks_with_center-Tuple{Symbol, Symbol, Int64}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator._leading_residual_ks_with_center","text":"_leading_residual_ks_with_center(\n    rule::Symbol,\n    boundary::Symbol,\n    Nsub::Int;\n    nterms::Int,\n    kmax::Int = 128\n) -> Tuple{Vector{Int}, Symbol}\n\nCollect the first nterms nonzero midpoint residual orders k (ascending) and report the expansion center.\n\nFunction description\n\nThis helper searches the midpoint-centered residual moments for a composite NS rule, and returns the first nterms derivative orders k for which the residual moment is nonzero.\n\nIt uses:\n\nCenter: displaystylec = fracN_textsub2  (returned as :mid)\nResidual test:\n\ntexttttextttdiff_k = intlimits_0^N_textsub du  left( u - c right)^k - sum_j=0^N_textsub beta_j  left( j - c right)^k \n\nIf textttdiff_k neq 0, then k is recorded.\n\nThis is useful for constructing multi-term convergence models where multiple nonzero residual orders are needed (e.g. fitting several powers).\n\nArguments\n\nrule: :ns_pK rule symbol (required by the current implementation).\nboundary: Boundary pattern (:LCRC, :LORC, :LCRO, :LORO).\nNsub: Number of subintervals for the composite rule.\nnterms: Number of nonzero k values to collect (must satisfy nterms ≥ 1).\nkmax: Maximum k to scan (inclusive).\n\nReturns\n\nks::Vector{Int}: First nterms residual derivative orders, sorted by scan order (ascending).\ncenter::Symbol: Expansion center indicator. Currently always :mid.\n\nErrors\n\nThrows (via Maranatha.JobLoggerTools.error_benji) if it cannot collect nterms values up to kmax.\nPropagates errors from exact beta assembly if (rule, boundary, Nsub) is invalid.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator.estimate_error-NTuple{7, Any}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator.estimate_error","text":"estimate_error(\n    f, \n    a, \n    b, \n    N, \n    dim, \n    rule,\n    boundary\n) -> Float64\n\nUnified interface for estimating integration error in arbitrary dimensions.\n\nFunction description\n\nDispatches to the corresponding dimension-specific estimator:\n\ndim == 1 rightarrow estimate_error_1d\ndim == 2 rightarrow estimate_error_2d\ndim == 3 rightarrow estimate_error_3d\ndim == 4 rightarrow estimate_error_4d\ndim >= 5 rightarrow estimate_error_nd\n\nArguments\n\nf: Integrand function (expects dim positional arguments).\na, b: Bounds for each dimension (interpreted as scalar bounds for a hypercube ab^textttdim).\nN: Number of subdivisions per axis (subject to rule constraints in 1-dimensional case; higher-dimensional error estimators reuse the same rule nodes/weights).\ndim: Number of dimensions (Int).\nrule: Integration rule symbol.\nboundary: Boundary pattern symbol (:LCRC, :LORC, :LCRO, :LORO). Required for NS rules.\n\nReturns\n\nA Float64 multidimensional error estimate.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator.estimate_error_1d-Tuple{Any, Real, Real, Int64, Symbol, Symbol}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator.estimate_error_1d","text":"estimate_error_1d(\n    f,\n    a::Real,\n    b::Real,\n    N::Int,\n    rule::Symbol,\n    boundary::Symbol\n) -> Float64\n\nEstimate the leading truncation error for a 1-dimensional composite Newton-Cotes rule using the exact midpoint residual expansion derived from rational weight assembly.\n\nFunction description\n\nThis routine computes a model-based leading truncation term consistent with the exact composite Newton–Cotes construction implemented in the Integrate module.\n\nThe procedure is:\n\nLet displaystyleh = fracb-aN.\nUsing the exact rational composite weights beta, determine the first nonzero midpoint residual order k and its exact coefficient:\n\ntextttdiff_k = intlimits_0^N_textsub du  left( u - c right)^k - sum_0^N_textsub beta_j  left( j - c right)^k\n\ntextttcoeff_k = fractextttdiff_kk\n\nwhere:\n\ndisplaystylec = fracN2 is the midpoint in dimensionless coordinate,\nbeta_j are the exact composite coefficients.\n\nEvaluate the k-th derivative of f at the physical midpoint:\n\nbarx = fraca+b2\n\nReturn the modeled leading error term:\n\nE = textttcoeff  h^k+1  f^kleft(barxright)\n\nThis matches the leading term of the Taylor expansion of the composite Newton-Cotes rule around the midpoint and is fully consistent with the exact rational assembly used in Maranatha.Integrate.\n\nMathematical structure\n\nIf the composite rule integrates monomials up to order m exactly, then the first nonzero residual term appears at derivative order k  m, and the truncation error behaves like:\n\nE = C_k  h^k+1  f^kleft(barxright) + left( texthigher-order terms right) \n\nThis routine returns exactly that leading term.\n\nArguments\n\nf:   Scalar callable integrand f(x) (function, closure, or callable struct).\na, b:   Lower and upper bounds of the integration interval.\nN:   Number of subintervals.   Must satisfy the composite tiling constraint for (rule, boundary).\nrule:   Composite Newton-Cotes rule symbol (must be :ns_pK style).\nboundary:   Boundary pattern (:LCRC, :LORC, :LCRO, :LORO).\n\nReturns\n\nFloat64:   Leading truncation error estimate.\n\nErrors\n\nPropagates any errors from:\ncomposite weight assembly,\nmidpoint residual extraction,\nderivative evaluation (nth_derivative).\nReturns 0.0 only if the detected residual order is k == 0 (degenerate or pathological case).\n\nNotes\n\nThis is a leading-term asymptotic model, not a strict upper bound.\nThe coefficient is derived from exact rational arithmetic and converted to Float64 only at the final stage.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator.estimate_error_2d-Tuple{Any, Real, Real, Int64, Symbol, Symbol}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator.estimate_error_2d","text":"estimate_error_2d(\n    f,\n    a::Real,\n    b::Real,\n    N::Int,\n    rule::Symbol,\n    boundary::Symbol\n) -> Float64\n\nEstimate the leading tensor-product truncation error for a 2-dimensional composite Newton-Cotes rule on the square domain ab^2.\n\nFunction description\n\nThis routine extends the 1-dimensional midpoint residual model axis-by-axis to tensor-product quadrature.\n\nLet displaystyleh = fracb-aN. From the exact 1-dimensional composite rule, determine the leading midpoint residual order k and its exact coefficient coeff.\n\nIn two dimensions, the tensor-product truncation error decomposes into axis-wise contributions:\n\nE = textttcoeff  h^k+1  left( I_x + I_y right)\n\nwhere:\n\ndisplaystyleI_x = int dy  fracpartial^k fpartial x^k left( barx  y right)\ndisplaystyleI_y = int dx  fracpartial^k fpartial y^k left( x  bary right)\n\nwith midpoint coordinates:\n\nbarx = bary = fraca+b2\n\nThe cross-axis integrals are evaluated numerically using the same composite quadrature weights.\n\nMathematical structure\n\nFor tensor-product rules, the leading truncation error separates as:\n\nE = C_k  h^k+1 left \nint dy  fracpartial^k fpartial x^k left( barx  y right) \n+ \nint dx  fracpartial^k fpartial y^k left( x  bary right) \nright \n+ left( texthigher-order terms right) \n\nMixed derivative contributions appear at higher asymptotic order and are not included in this leading model.\n\nArguments\n\nf:   Scalar callable integrand f(xy) (function, closure, or callable struct).\na, b:   Scalar bounds defining the square domain ab^2.\nN:   Number of subintervals per axis.\nrule:   Composite Newton-Cotes rule symbol (must be :ns_pK style).\nboundary:   Boundary pattern (:LCRC, :LORC, :LCRO, :LORO).\n\nReturns\n\nFloat64:   Leading tensor-product truncation error estimate.\n\nErrors\n\nPropagates any errors from:\ncomposite weight assembly,\nmidpoint residual extraction,\nderivative evaluation (nth_derivative).\n\nNotes\n\nThis routine models only the leading separable contribution.\nMixed derivative terms of the form displaystylefracpartial^r partial^s fpartial x^r partial y^s appear at higher orders and are intentionally omitted.\nCoefficients originate from exact rational composite weights.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator.estimate_error_3d-Tuple{Any, Real, Real, Int64, Symbol, Symbol}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator.estimate_error_3d","text":"estimate_error_3d(\n    f,\n    a::Real,\n    b::Real,\n    N::Int,\n    rule::Symbol,\n    boundary::Symbol\n) -> Float64\n\nEstimate the leading tensor-product truncation error for a 3-dimensional composite Newton-Cotes rule on the cube ab^3 using the exact midpoint residual expansion.\n\nFunction description\n\nThis routine generalizes the 1-dimensional midpoint residual model to a 3-dimensional tensor-product setting by applying the 1-dimensional midpoint error operator along each axis and numerically integrating the resulting derivative across the remaining axes.\n\nLet displaystyleh = fracb-aN.  From the exact rational composite weights associated with (rule, boundary, N), the code extracts:\n\nthe leading nonzero residual order k, and\nthe corresponding exact rational coefficient coeffR.\n\nThe modeled leading truncation error is:\n\nE = textttcoeff  h^k+1  left( I_x + I_y + I_z right)\n\nwhere:\n\ncoeff = Float64(coeffR),\ndisplaystyleI_x = intint dy dz  fracpartial^k fpartial x^k left( barx  y  z right)\ndisplaystyleI_y = intint dz dx  fracpartial^k fpartial y^k left( x  bary  z right)\ndisplaystyleI_z = intint dx dy  fracpartial^k fpartial z^k left( x  y  barz right)\n\nand displaystylebarx = bary = barz = fraca+b2. Each cross-axis integral is computed using the same 1-dimensional quadrature nodes/weights along the other axes.\n\nMathematical structure\n\nFor a tensor-product quadrature on ab^3 the leading error contribution separates into axis-wise terms:\n\nE = C_k  h^k+1 left \nintint dy dz  fracpartial^k fpartial x^k left( barx  y  z right) \n+  \nintint dz dx  fracpartial^k fpartial y^k left( x  bary  z right) \n+  \nintint dx dy  fracpartial^k fpartial z^k left( x  y  barz right) \nright \n+ left( texthigher-order terms right) \n\nMixed-derivative contributions and higher residual orders are not included in this leading model.\n\nArguments\n\nf:   Scalar callable integrand f(xyz) (function, closure, or callable struct).\na, b:   Scalar bounds defining the cube domain ab^3.\nN:   Number of subintervals per axis.   Must satisfy the composite tiling constraint for (rule, boundary).\nrule:   Composite Newton-Cotes rule symbol (must be :ns_pK style).\nboundary:   Boundary pattern (:LCRC, :LORC, :LCRO, :LORO).\n\nReturns\n\nFloat64:   Leading tensor-product truncation error estimate.\n\nErrors\n\nPropagates any errors from:\nmidpoint residual extraction,\ncomposite weight generation,\nderivative evaluation (nth_derivative).\n\nNotes\n\nThis is a leading-term asymptotic model, not a rigorous bound.\nCoefficients come from exact rational arithmetic and are converted to Float64 only at the final stage.\nReturns 0.0 if the residual scan reports k == 0 (degenerate/unexpected case).\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator.estimate_error_4d-Tuple{Any, Real, Real, Int64, Symbol, Symbol}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator.estimate_error_4d","text":"estimate_error_4d(\n    f,\n    a::Real,\n    b::Real,\n    N::Int,\n    rule::Symbol,\n    boundary::Symbol\n) -> Float64\n\nEstimate the leading tensor-product truncation error for a 4-dimensional composite Newton-Cotes rule on the hypercube ab^4 using the exact midpoint residual expansion.\n\nFunction description\n\nThis routine extends the 1-dimensional midpoint residual model to four dimensions by applying the 1-dimensional midpoint error operator along each axis and integrating over the remaining three axes using tensor-product quadrature.\n\nLet displaystyleh = fracb-aN. The leading midpoint residual order k and its coefficient coeffR are extracted from the exact rational composite weights for the 1-dimensional rule associated with (rule, boundary, N).\n\nThe returned model is:\n\nE = textttcoeff  h^k+1  left( I_x + I_y + I_z + I_t right)\n\nwith coeff = Float64(coeffR) and midpoint coordinates:\n\nbarx = bary = barz = bart = fraca+b2 \n\nThe axis contributions are:\n\ndisplaystyleI_x = intintint dy dz dt  fracpartial^k fpartial x^k left( barx  y  z  t right)\ndisplaystyleI_y = intintint dz dt dx  fracpartial^k fpartial y^k left( x  bary  z  t right)\ndisplaystyleI_z = intintint dt dx dy  fracpartial^k fpartial z^k left( x  y  barz  t right)\ndisplaystyleI_t = intintint dx dy dz  fracpartial^k fpartial t^k left( x  y  z  bart right)\n\nEach integral is computed numerically using the same 1-dimensional quadrature nodes/weights.\n\nMathematical structure\n\nFor tensor-product quadrature on ab^4 the leading separable error model is:\n\nE = C_k  h^k+1 left \nintintint dy dz dt  fracpartial^k fpartial x^k left( barx  y  z  t right) \n+  \nintintint dz dt dx  fracpartial^k fpartial y^k left( x  bary  z  t right) \n+  \nintintint dt dx dy  fracpartial^k fpartial z^k left( x  y  barz  t right) \n+  \nintintint dx dy dz  fracpartial^k fpartial t^k left( x  y  z  bart right) \nright \n+ left( texthigher-order terms right) \n\nHigher-order residual terms and mixed-derivative corrections are omitted.\n\nArguments\n\nf:   Scalar callable integrand f(xyzt) (function, closure, or callable struct).\na, b:   Scalar bounds defining the hypercube ab^4.\nN:   Number of subintervals per axis (must satisfy composite constraints for (rule, boundary)).\nrule:   Composite Newton-Cotes rule symbol (must be :ns_pK style).\nboundary:   Boundary pattern (:LCRC, :LORC, :LCRO, :LORO).\n\nReturns\n\nFloat64:   Leading tensor-product truncation error estimate.\n\nErrors\n\nPropagates any errors from:\ncomposite weight assembly,\nmidpoint residual extraction,\nderivative evaluation (nth_derivative).\n\nNotes\n\nThis routine intentionally returns a leading-term error scale.\nCoefficients come from exact rational arithmetic and are converted to Float64 only at the final stage.\nReturns 0.0 if the residual scan reports k == 0 (degenerate/unexpected case).\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator.estimate_error_nd-Tuple{Any, Real, Real, Int64, Symbol, Symbol}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator.estimate_error_nd","text":"estimate_error_nd(\n    f,\n    a::Real,\n    b::Real,\n    N::Int,\n    rule::Symbol,\n    boundary::Symbol;\n    dim::Int\n) -> Float64\n\nEstimate the leading tensor-product truncation error for an arbitrary-dimensional composite Newton-Cotes rule on the hypercube ab^textttdim using the exact midpoint residual expansion.\n\nFunction description\n\nThis routine provides a dimension-generic version of the axis-separated midpoint error model.\n\nLet displaystyleh = fracb-aN. From the exact rational composite weight assembly for (rule, boundary, N), it determines:\n\nthe leading midpoint residual order k, and\nits exact rational coefficient coeffR.\n\nThe model returned is:\n\nE = textttcoeff  h^k+1  sum_mu=1^textttdim I_mu\n\nwhere coeff = Float64(coeffR) and each I_mu is the tensor-product integral over the remaining textttdim-1 coordinates of the k-th partial derivative along the selected axis evaluated at the physical midpoint along that axis:\n\nmidpoint along any axis: displaystylebarx = fraca+b2\nfor each axis mu, define:\n\nI_mu = int cdots int left( prod_nu neq mu dx_nu right)  fracpartial^k fpartial x_mu^k left( x_1  ldots  x_mu=barx  ldots  x_textttdim right)\n\nNumerically, the cross-axis integral is computed by enumerating the (textttdim-1)-fold tensor-product grid over the 1D nodes xs, accumulating the product weights, and evaluating nth_derivative on the resulting 1D slice (with one coordinate left as the differentiation variable).\n\nImplementation notes\n\nThe helper _call_with_axis constructs the argument tuple for f by replacing only one coordinate (axis) with the differentiation variable x (which may be a Dual).\nThe enumeration over the (textttdim-1) indices is implemented in odometer style.\nFor dim == 1, the routine falls back to a direct derivative evaluation.\n\nArguments\n\nf:   Callable integrand expecting exactly dim positional arguments.\na, b:   Scalar bounds defining the hypercube ab^textttdim.\nN:   Number of subintervals per axis.   Must satisfy the composite tiling constraint for (rule, boundary).\nrule:   Composite Newton-Cotes rule symbol (must be :ns_pK style).\nboundary:   Boundary pattern (:LCRC, :LORC, :LCRO, :LORO).\ndim:   Dimensionality of the integral (must satisfy textttdim ge 1).\n\nReturns\n\nFloat64:   Leading tensor-product truncation error estimate in dim dimensions.\n\nErrors\n\nThrows ArgumentError if dim < 1.\nPropagates any errors from:\ncomposite weight assembly,\nmidpoint residual extraction,\nderivative evaluation (nth_derivative).\n\nNotes\n\nThe model is axis-separated (sum of single-axis error operators). Mixed-derivative contributions and higher residual orders are omitted.\nReturns 0.0 if the residual scan reports k == 0 (degenerate/unexpected case).\nComplexity grows as O(textttdim  (N+1)^textttdim-1) derivative evaluations, so this estimator can be expensive for large dim at high resolution.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator.nth_derivative-Tuple{Any, Any, Any}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator.nth_derivative","text":"nth_derivative(\n    g,\n    x,\n    n;\n    h,\n    rule,\n    N,\n    dim::Int,\n    side::Symbol = :mid,\n    axis = 0,\n    stage::Symbol = :mid\n) -> Real\n\nSafely compute the n-th derivative of scalar callable g at point x.\n\nFunction description\n\nThis wrapper:\n\nAttempts to compute the derivative using nth_derivative_forwarddiff  (ForwardDiff.jl-based).\nIf the result is non-finite, logs a warning and retries using nth_derivative_taylor.\nIf still non-finite, emits a fatal error  via Maranatha.JobLoggerTools.error_benji.\n\nIt is designed to be shared across 1D, 2D, 3D, 4D, and general nD error estimators.\n\nKeyword arguments\n\nh     : Grid spacing.\nrule  : Quadrature rule symbol.\nN     : Number of subdivisions.\ndim   : Problem dimensionality.\nside  : :L, :R, or :mid (boundary location indicator).\naxis  : Axis index or symbolic name (for logging).\nstage : :midpoint or :boundary (error-model stage).\n\nReturns\n\nThe finite n-th derivative value f^(n)(x).\n\nNotes\n\nThis function is marked @inline so that Julia can inline it into tight quadrature loops without overhead.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator.nth_derivative_enzyme-Tuple{Any, Real, Int64}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator.nth_derivative_enzyme","text":"nth_derivative_enzyme(\n    f,\n    x::Real,\n    n::Int\n)\n\nCompute the n-th derivative of a scalar callable f at a scalar point x using repeated reverse-mode differentiation via Enzyme.jl.\n\nFunction description\n\nThis routine constructs a nested closure chain of length n, where each step applies Enzyme.gradient in reverse mode to obtain a first derivative. The resulting callable is then evaluated at x.\n\nThis mirrors the structure of the ForwardDiff.jl-based implementation but replaces forward-mode differentiation with Enzyme.jl's reverse-mode AD. It is intended primarily for benchmarking and experimentation with Enzyme.jl in scalar high-order differentiation contexts.\n\nSupported callable types include:\n\nordinary functions,\nanonymous closures,\ncallable structs (functors).\n\nArguments\n\nf: Scalar-to-scalar callable (f(x)::Number expected).\nx::Real: Evaluation point.\nn::Int: Derivative order (must be nonnegative).\n\nReturns\n\nThe n-th derivative value f^(n)(x).\n\nNotes\n\nReverse-mode AD is typically advantageous for many-input/one-output problems. For repeated scalar higher-order derivatives, performance may be worse than ForwardDiff.jl due to closure nesting and gradient reconstruction overhead.\nThis implementation intentionally preserves the closure-based structure for fair benchmarking against other approaches.\nInputs are converted to Float64 to match surrounding numeric conventions.\nProvided as a benchmarking reference implementation, not as the recommended production path in the current codebase.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator.nth_derivative_forwarddiff-Tuple{Any, Real, Int64}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator.nth_derivative_forwarddiff","text":"nth_derivative_forwarddiff(\n    f, \n    x::Real, \n    n::Int\n)\n\nCompute the n-th derivative of a scalar callable f at a scalar point x using repeated ForwardDiff.derivative.\n\nFunction description\n\nThis routine is intentionally written to accept any callable object f, not only subtypes of Function. This includes:\n\nordinary functions,\nanonymous closures,\ncallable structs (functors) such as preset integrands.\n\nThis design is required for compatibility with the integrand registry and preset-style callable wrappers while preserving ForwardDiff.jl-based behavior.\n\nArguments\n\nf: Scalar-to-scalar callable (e.g., f(x)::Number).\nx::Real: Point at which the derivative is evaluated.\nn::Int: Derivative order (nonnegative integer).\n\nReturns\n\nThe n-th derivative value f^(n)(x).\n\nNotes\n\nThis implementation constructs a nested closure chain of length n and then evaluates it at x. This intentionally matches the original behavior.\nType restriction f::Function is intentionally avoided because callable structs are not subtypes of Function, but must be supported.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator.nth_derivative_taylor-Tuple{Any, Real, Int64}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator.nth_derivative_taylor","text":"nth_derivative_taylor(\n    f,\n    x::Real,\n    n::Int\n)\n\nCompute the n-th derivative of a scalar callable f at a scalar point x using a Taylor expansion via TaylorSeries.jl.\n\nFunction description\n\nThis routine evaluates the Taylor expansion of f(x + t) around x up to order n using a TaylorSeries.Taylor1 expansion variable.   The n-th derivative is obtained from the n-th Taylor coefficient multiplied by n.\n\nUnlike the ForwardDiff.jl implementation, this method performs higher-order differentiation in a single pass rather than recursively applying first derivatives. It is useful for benchmarking alternative AD strategies and for testing high-order derivative extraction based on truncated power-series arithmetic.\n\nThis function accepts any callable object f, including:\n\nordinary functions,\nanonymous closures,\ncallable structs (functors).\n\nArguments\n\nf: Scalar-to-scalar callable (f(x)::Number expected).\nx::Real: Evaluation point.\nn::Int: Derivative order (must be nonnegative).\n\nReturns\n\nThe n-th derivative value f^(n)(x).\n\nNotes\n\nInternally converts x to Float64 to match the surrounding numeric policy.\nThis method may allocate significantly more memory than ForwardDiff.jl, especially when used inside large loops or with high expansion orders.\n\n\n\n\n\n","category":"method"},{"location":"lib/F0000Preset/#Maranatha.F0000Preset","page":"F0000Preset","title":"Maranatha.F0000Preset","text":"","category":"section"},{"location":"lib/F0000Preset/#Maranatha.F0000Preset.F0000Integrand","page":"F0000Preset","title":"Maranatha.F0000Preset.F0000Integrand","text":"struct F0000Integrand\n\nCallable wrapper integrand for the F0000 computation on t ∈ [0, 1].\n\nstruct description\n\nThis struct provides a user-friendly, callable integrand object that can be passed directly to Maranatha.Runner.run_Maranatha. Internally, it delegates to\n\nF0000GammaEminus1.gtilde_F0000(t; p=p, eps=eps),\n\nwhich implements the transformed integrand after the substitution y = t^p for the original F0000 integral.\n\nFields\n\np::Int: Power in the substitution y = t^p (integer, typically 2–4).\neps::Float64: Endpoint cutoff (stored as Float64) used by gtilde_F0000 to suppress singular behavior near t = 0 and t = 1.\n\nNotes\n\nTo remain compatible with automatic differentiation (e.g., ForwardDiff.Dual values of t), this wrapper stores eps as Float64 but converts it to typeof(t) at call time.\nThis preserves the original numerical behavior for normal Float64 usage while preventing keyword-type mismatches under AD.\n\n\n\n\n\n","category":"type"},{"location":"lib/F0000Preset/#Maranatha.F0000Preset.F0000Integrand-Tuple{Any}","page":"F0000Preset","title":"Maranatha.F0000Preset.F0000Integrand","text":"(f::F0000Integrand)(t)\n\nEvaluate the F0000 transformed integrand at t.\n\nArguments\n\nt: Real scalar in [0, 1] (may also be a dual number under AD).\n\nReturns\n\nThe value of g̃(t) as returned by F0000GammaEminus1.gtilde_F0000(t; p=f.p, eps=convert(typeof(t), f.eps)).\n\nNotes\n\neps is converted to typeof(t) to keep the keyword argument type-consistent when t is a ForwardDiff.Dual.\n\n\n\n\n\n","category":"method"},{"location":"lib/F0000Preset/#Maranatha.F0000Preset.__register_F0000_integrand__-Tuple{}","page":"F0000Preset","title":"Maranatha.F0000Preset.__register_F0000_integrand__","text":"__register_F0000_integrand__()\n\nRegister the :F0000 integrand factory into Maranatha.Integrands.\n\nFunction description\n\nThis function installs the factory factory_F0000 into the project-wide integrand registry, enabling the user-facing construction:\n\nMaranatha.Integrands.integrand(:F0000; p=..., eps=...).\n\nReturns\n\nnothing\n\nNotes\n\nThis is intended to be called once during package/module initialization (e.g., from src/Maranatha.jl after including this file).\n\n\n\n\n\n","category":"method"},{"location":"lib/F0000Preset/#Maranatha.F0000Preset.factory_F0000-Tuple{}","page":"F0000Preset","title":"Maranatha.F0000Preset.factory_F0000","text":"factory_F0000(; \n  p::Int=2, \n  eps::Float64=1e-15\n)\n\nFactory for constructing the registered F0000 integrand.\n\nFunction description\n\nThis factory is registered under the name :F0000 in the integrand registry. It returns a callable F0000Integrand instance that can be used as a standard integrand function.\n\nKeyword arguments\n\np::Int=2: Substitution power used in y = t^p.\neps::Float64=1e-15: Endpoint cutoff forwarded to gtilde_F0000.\n\nReturns\n\nF0000Integrand: Callable integrand object.\n\nNotes\n\neps is stored as Float64 but promoted to typeof(t) when evaluating the integrand. This makes the preset safe under ForwardDiff while keeping the default behavior deterministic for typical Float64 runs.\n\n\n\n\n\n","category":"method"},{"location":"lib/LeastChiSquareFit/#Maranatha.LeastChiSquareFit","page":"LeastChiSquareFit","title":"Maranatha.LeastChiSquareFit","text":"","category":"section"},{"location":"lib/LeastChiSquareFit/#Maranatha.LeastChiSquareFit.least_chi_square_fit-Tuple{Real, Real, Any, Any, Any, Symbol, Symbol}","page":"LeastChiSquareFit","title":"Maranatha.LeastChiSquareFit.least_chi_square_fit","text":"least_chi_square_fit(\n    a::Real,\n    b::Real,\n    hs,\n    estimates,\n    errors,\n    rule::Symbol;\n    nterms::Int = 2\n)\n\nPerform a h to 0 (zero step-size limit) extrapolation using least-chi^2 fitting for the quadrature estimate, and return both best-fit parameters and their uncertainties.\n\nFunction description\n\nThis routine fits a rule-dependent convergence ansatz that is linear in its parameters, using weighted least squares (WLS). The step size is provided by the caller as displaystyleh = fracb-aN (via hs), and the convergence exponents are inferred from the composite Newton-Cotes midpoint residual model, which depends on (rule, boundary) and a representative subdivision count Nref derived from the smallest step size in hs.\n\nThe convergence model is selected by the number of basis terms nterms (including the constant term). The design matrix is constructed as:\n\ncolumn 1: h^0  (constant term)\ncolumns 2..nterms: h^p_1, h^p_2, ..., where the exponents p_t are obtained from the composite Newton-Cotes midpoint residual model (via Maranatha.ErrorEstimator._leading_residual_ks_with_center), and are used as-is to build the design matrix.\n\nEquivalently, the fitted form is:\n\nI(h) = I_0 + C_1  h^p_1 + C_2  h^p_2 + C_3  h^p_3 + ldots\n\nSolve (WLS)\n\nLet X be the design matrix, y the estimates, and sigma the pointwise errors. Weights are constructed as W = sigma_ii^-1, and the WLS normal equations are solved in the numerically stable form:\n\nleft( W X right)  bmlambda = left( W  y right) \n\nyielding displaystylebmlambda = beginbmatrix I_0  C_1  C_2  cdots endbmatrix^mathsfT.\n\nParameter covariance and errors\n\nThis implementation computes Hessian-based propagation, but evaluates the needed inverse-Hessian actions via a Cholesky factorization rather than forming inv(H) explicitly.\n\nBuild the normal matrix A = X^mathsfT  W^2  X.\nDefine the χ² Hessian as H = 2A.\nFactorize the Hessian H = L  L^mathsfT via cholesky(Symmetric(H)) (requires Symmetric Positive Definite (SPD)).\nDefine H^-1 implicitly through linear solves with the Cholesky factor.\nThe parameter covariance matrix V is then taken as\n\nV = Delta = 4  H^-1  A  H^-1 \n\nand the 1  sigma errors of fitting parameters are sqrttextdiag(V).\n\nWhy H = 2  A?\n\nFor the WLS objective chi^2(bmlambda) = leftlvert W left( X  bmlambda - mathbfy right) rightrvert^2, the gradient is nabla chi^2 = 2 X^mathsfT  W^2  left( X  bmlambda - mathbfy right) and the Hessian is nabla^2 chi^2 = 2 X^mathsfT  W^2  X = 2  A. So this factor of 2 is exact for this model.\n\nNotes:\n\nIf you prefer the standard WLS covariance (Gauss-Markov for linear models), you can instead use V = left( X^mathsfT  W^2  X right)^-1.\nThe returned cov is intended for downstream use (e.g. to draw a fit-band via sigma_textfit^2(h) = varphi(h)^mathsfT  V  varphi(h)).\n\nArguments\n\nhs: Vector-like collection of step sizes displaystyleh = fracb-aN.\nestimates: Vector-like collection of quadrature estimates I(h).\nerrors: Vector-like collection of error estimates associated with I(h).\nrule: Quadrature rule symbol used to select the leading convergence power p.\n\nKeyword arguments\n\nnterms::Int=2: Number of basis terms in the convergence model (including the constant term). Must satisfy ntermsge 2.\n\nReturns\n\nA NamedTuple with the following fields:\n\nestimate::Float64: Extrapolated value I_0 = I(h to 0) (i.e. params[1]).\nestimate_error::Float64: One-sigma uncertainty for I_0, taken from the covariance diagonal.\nparams::Vector{Float64}: Fitted parameter vector [I0, C1, C2, ...].\nparam_errors::Vector{Float64}: 1  sigma uncertainties for params.\ncov::Matrix{Float64}: Parameter covariance matrix.\nchisq::Float64: chi^2 value.\nredchisq::Float64: chi^2textdof.\ndof::Int: Degrees of freedom, length(y) - length(params).\n\nErrors\n\nThrows an error if rule is not recognized.\nThrows an error if nterms < 2.\nThrows an error if the Hessian is not positive definite (Cholesky fails).\nNote: If dof == 0, the computation of redchisq = chisq / dof involves division by zero. Under IEEE floating-point semantics, this results in Inf or NaN depending on the value of chisq.\n\n\n\n\n\n","category":"method"},{"location":"lib/LeastChiSquareFit/#Maranatha.LeastChiSquareFit.print_fit_result-Tuple{Any}","page":"LeastChiSquareFit","title":"Maranatha.LeastChiSquareFit.print_fit_result","text":"print_fit_result(\n    fit\n) -> Nothing\n\nPrint a formatted summary of a convergence fit result.\n\nFunction description\n\nThis routine prints each fitted parameter lambda_k with its 1  sigma uncertainty using Maranatha.AvgErrFormatter.avgerr_e2d_from_float, followed by chi^2 diagnostics  and the extrapolated result I(h to 0).\n\nThe output formatting and ordering are intentionally kept identical to the original implementation.\n\nArguments\n\nfit: Fit result object (typically the NamedTuple returned by least_chi_square_fit) that provides the fields:\nestimate::Float64: Extrapolated value I_0 = I(h to 0) (i.e. params[1]).\nestimate_error::Float64: One-sigma uncertainty for I_0, taken from the\ncovariance diagonal.\nparams::Vector{Float64}: Fitted parameter vector [I0, C1, C2, ...].\nparam_errors::Vector{Float64}: 1  sigma uncertainties for params.\ncov::Matrix{Float64}: Parameter covariance matrix.\nchisq::Float64: chi^2 value.\nredchisq::Float64: chi^2textdof.\ndof::Int: Degrees of freedom, length(y) - length(params).\n\nReturns\n\nnothing.\n\n\n\n\n\n","category":"method"},{"location":"#Maranatha.jl-Project-Documentation","page":"Home","title":"Maranatha.jl Project Documentation","text":"Welcome to the documentation for the Maranatha.jl!","category":"section"},{"location":"#Maranatha.Maranatha","page":"Home","title":"Maranatha.Maranatha","text":"module Maranatha\n\nMaranatha.jl is a modular Newton-Cotes-based toolkit for multi-dimensional quadrature, error-scale modeling, and least chi^2 fitting for h to 0 extrapolation on hypercube domains left a b right^n where n is the (spacetime) dimensionality.\n\nMaranatha.jl is designed around a pipeline-oriented workflow:\n\nintegration\nerror estimation\nh to 0 extrapolation via least chi^2 fitting\nvisualization using PyPlot.jl.\n\nThe internal structure is intentionally split into small, independent submodules so that numerical components, logging, plotting, and preset integrands can evolve without tightly coupling the codebase.\n\nArchitecture overview\n\nIntegration layer\n\nMaranatha.Integrate module provides a unified front-end for tensor-product Newton-Cotes quadrature in arbitrary dimensions. The concrete rule implementations are kept internal and are not part of the public API surface. The quadrature core uses an exact-moment / Taylor-expansion-based construction to support general multi-point composite Newton-Cotes rules through a unified implementation (including configurable endpoint openness via boundary patterns). Legacy hard-coded rule tables are intentionally removed.\n\nError modeling\n\nThe Maranatha.ErrorEstimator module supplies lightweight derivative-based error (scale) estimators that follow a tensor-product philosophy across dimensions. The estimator uses a lightweight derivative-based error scale model whose leading term is determined from the composite Newton-Cotes midpoint residual moments computed from the exact composite weights (assembled rationally and converted to floating-point only at the final stage). This provides consistent h-scaling weights for least-chi^2 fitting across dimensions.\n\nThis estimator is not a rigorous truncation bound; it is designed to produce consistent scaling weights for least chi^2 fitting for h to 0 extrapolation.\n\nLeast chi^2 fitting\n\nMaranatha.LeastChiSquareFit submodule performs least chi^2 fitting for h to 0 extrapolation using a residual-informed exponent basis derived from the composite Newton-Cotes midpoint residual expansion.\n\nThe fitted model is linear in its parameters:\n\nI(h) = sum_texttti=1^n lambda_texttti  h^textttpowersi\n\nwhere the exponent vector powers is determined during fitting and stored in the fit result (e.g. fit_result.powers, with powers[1] = 0 for the constant term).\n\nThe routine also returns the parameter covariance matrix, enabling covariance-propagated uncertainty bands in convergence plots.\n\nIntegrand system\n\nThe Maranatha.Integrands submodule implements a registry-based preset system that allows named integrands to be constructed via factories while still accepting plain Julia callables (functions, closures, callable structs).\n\nThis design keeps user-facing workflows simple without sacrificing flexibility.\n\nExecution layer\n\nMaranatha.Runner.run_Maranatha is the main orchestration entry point.   It performs:\n\nmulti-resolution integration,\nerror-scale estimation,\nleast chi^2 fitting for h to 0 extrapolation,\nformatted reporting of results.\n\nUsers typically interact only with this high-level interface.\n\nPlotting utilities\n\nMaranatha.PlotTools.plot_convergence_result generates publication-style convergence figures using PyPlot.jl with LaTeX rendering. The shaded band represents the full covariance-propagated 1  sigma uncertainty of the fitted model. The plot reconstruction uses the exact exponent basis stored in the fit result (e.g. fit_result.powers) together with the parameter covariance (e.g. fit_result.cov), ensuring consistency with the fitted model.\n\nLogging\n\nAll runtime diagnostics are handled by Maranatha.JobLoggerTools, which provides timestamped logging, stage delimiters, and timing macros used consistently throughout the pipeline.\n\nPublic API\n\nThe top-level Maranatha namespace re-exports a minimal set of entry points:\n\nMaranatha.Runner.run_Maranatha   Perform numerical integration, error estimation, and least chi^2 fitting for h to 0 extrapolation.\nMaranatha.PlotTools.plot_convergence_result   Visualize convergence behavior and fitted uncertainty bands.\n\nInternal submodules remain accessible but are not required for normal usage.\n\nDimensionality\n\nA generalized n-dimensional implementation is provided following the same tensor-product philosophy, with dimension-specific specializations available for lower dimensions. Because tensor enumeration scales rapidly with dimension, higher-dimensional usage is primarily intended for controlled numerical studies.\n\nDesign goals\n\nPipeline-oriented structure rather than rule-centric APIs.\nStrict separation between numerical core, orchestration, and visualization.\nReproducible floating-point behavior through preserved loop ordering.\nMinimal public API surface with extensible internal modules.\nUnified general n-point Newton–Cotes support via Taylor/moment-based rule construction (no legacy rule tables).\n\n\n\n\n\n","category":"module"}]
}
