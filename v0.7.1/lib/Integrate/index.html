<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Integrate · Maranatha.jl</title><meta name="title" content="Integrate · Maranatha.jl"/><meta property="og:title" content="Integrate · Maranatha.jl"/><meta property="twitter:title" content="Integrate · Maranatha.jl"/><meta name="description" content="Documentation for Maranatha.jl."/><meta property="og:description" content="Documentation for Maranatha.jl."/><meta property="twitter:description" content="Documentation for Maranatha.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Maranatha.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../Runner/">Runner</a></li><li><a class="tocitem" href="../Integrands/">Integrands</a></li><li class="is-active"><a class="tocitem" href>Integrate</a></li><li><a class="tocitem" href="../ErrorEstimator/">ErrorEstimator</a></li><li><a class="tocitem" href="../LeastChiSquareFit/">LeastChiSquareFit</a></li><li><a class="tocitem" href="../PlotTools/">PlotTools</a></li><li><a class="tocitem" href="../AvgErrFormatter/">AvgErrFormatter</a></li><li><a class="tocitem" href="../JobLoggerTools/">JobLoggerTools</a></li><li><input class="collapse-toggle" id="menuitem-2-9" type="checkbox"/><label class="tocitem" for="menuitem-2-9"><span class="docs-label">examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../F0000GammaEminus1/">F0000GammaEminus1</a></li><li><a class="tocitem" href="../F0000Preset/">F0000Preset</a></li><li><a class="tocitem" href="../Z_q/">Z_q</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Integrate</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Integrate</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/saintbenjamin/Maranatha.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Maranatha.Integrate"><a class="docs-heading-anchor" href="#Maranatha.Integrate">Maranatha.Integrate</a><a id="Maranatha.Integrate-1"></a><a class="docs-heading-anchor-permalink" href="#Maranatha.Integrate" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="Maranatha.Integrate._NS_BETA_CACHE"><a class="docstring-binding" href="#Maranatha.Integrate._NS_BETA_CACHE"><code>Maranatha.Integrate._NS_BETA_CACHE</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">_NS_BETA_CACHE :: Dict{Tuple{Int,Symbol,Int}, Vector{Float64}}</code></pre><p>Cache for <code>Float64</code> composite Newton-Cotes coefficient vectors.</p><p><strong>Description</strong></p><p>This dictionary stores previously constructed global coefficient vectors <span>$\beta$</span> (after conversion to <code>Float64</code>) to avoid repeated expensive exact-rational assembly.</p><p>The cache key is:</p><pre><code class="language-julia hljs">(p, boundary, Nsub)</code></pre><p>where:</p><ul><li><code>p</code>        : local Newton-Cotes node count (e.g. 3, 4, 5, ...)</li><li><code>boundary</code> : boundary pattern (<code>:LCRC</code>, <code>:LORC</code>, <code>:LCRO</code>, <code>:LORO</code>)</li><li><code>Nsub</code>     : number of global subintervals</li></ul><p>The stored value is:</p><pre><code class="language-julia hljs">Vector{Float64}  # length Nsub + 1</code></pre><p>representing the global coefficient vector <code>β</code> such that:</p><p class="math-container">\[\texttt{ws}_j = \beta_j \, h\]</p><p>with <span>$\displaystyle{h = \frac{b-a}{N_{\text{sub}}}}$</span>.</p><p><strong>Purpose</strong></p><p>Exact rational assembly via <a href="#Maranatha.Integrate._assemble_composite_beta_rational-Tuple{Int64, Symbol, Int64}"><code>_assemble_composite_beta_rational</code></a> can be computationally heavy for large <span>$p$</span> or repeated calls. This cache ensures that identical quadrature configurations reuse previously computed weights.</p><p><strong>Notes</strong></p><ul><li>The cache is process-local (not persistent across sessions).</li><li>Memory usage grows with distinct <code>(p, boundary, Nsub)</code> triples.</li><li>Safe for repeated deterministic use since values are immutable <code>Vector{Float64}</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/saintbenjamin/Maranatha.jl/blob/5a88455c9c82cb5ebc846519828a97b7044345f8/src/generator/Integrate.jl#L130-L169">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Maranatha.Integrate.RBig"><a class="docstring-binding" href="#Maranatha.Integrate.RBig"><code>Maranatha.Integrate.RBig</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RBig = Rational{BigInt}</code></pre><p>Exact rational number type used for composite Newton-Cotes weight assembly.</p><p><strong>Description</strong></p><p><code>RBig</code> is defined as:</p><pre><code class="language-julia hljs">Rational{BigInt}</code></pre><p>and is used throughout the exact composite Newton-Cotes construction to guarantee that:</p><ul><li>All local moment integrals are computed exactly.</li><li>All Vandermonde systems for local weights <span>$\alpha$</span> are solved in exact arithmetic.</li><li>The assembled global coefficient vector <span>$\beta$</span> is mathematically exact before conversion to <code>Float64</code>.</li></ul><p>This prevents any floating-point contamination during symbolic-like weight construction.</p><p><strong>Design rationale</strong></p><p>Composite Newton-Cotes weights can involve large rational coefficients. Using <code>Rational{BigInt}</code> ensures:</p><ul><li>No loss of precision during assembly.</li><li>Exact cancellation between overlapping local blocks.</li><li>Deterministic reproducibility independent of floating-point rounding.</li></ul><p>Conversion to <code>Float64</code> happens only in <a href="#Maranatha.Integrate._get_beta_float-Tuple{Int64, Symbol, Int64}"><code>_get_beta_float</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/saintbenjamin/Maranatha.jl/blob/5a88455c9c82cb5ebc846519828a97b7044345f8/src/generator/Integrate.jl#L97-L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Maranatha.Integrate._assemble_composite_beta_rational-Tuple{Int64, Symbol, Int64}"><a class="docstring-binding" href="#Maranatha.Integrate._assemble_composite_beta_rational-Tuple{Int64, Symbol, Int64}"><code>Maranatha.Integrate._assemble_composite_beta_rational</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_assemble_composite_beta_rational(
    p::Int, 
    boundary::Symbol, 
    Nsub::Int
) -&gt; Vector{RBig}</code></pre><p>Assemble the global composite Newton-Cotes coefficient vector <span>$\beta$</span> in exact rational form.</p><p><strong>Function description</strong></p><p>This is the core exact assembly routine. It builds a global coefficient vector <span>$\beta$</span> (length <span>$N_\text{sub}+1$</span>) such that the composite quadrature weights are:</p><p class="math-container">\[\texttt{ws}_j = \beta_j \, h \, \quad \text{with} \quad h = \frac{b-a}{N_\text{sub}}\]</p><p>The algorithm:</p><ol><li>Validates the tiling constraint via <a href="#Maranatha.Integrate._check_condition-Tuple{Int64, Symbol, Int64}"><code>_check_condition</code></a>.</li><li>Builds the left boundary block (closed or opened as requested).</li><li>Adds <span>$m$</span> interior closed blocks (each width <span>$p-1$</span>).</li><li>Builds the right boundary block (closed or opened as requested).</li><li>Accumulates all contributions into a single global <span>$\beta$</span>.</li></ol><p>All computations remain in <code>RBig = Rational{BigInt}</code> to preserve exactness.</p><p><strong>Arguments</strong></p><ul><li><code>p</code>: Local node count (NC <em>order</em> in this implementation; must satisfy <span>$p \ge 2$</span>).</li><li><code>boundary</code>: Boundary pattern (<code>:LCRC</code>, <code>:LORC</code>, <code>:LCRO</code>, <code>:LORO</code>).</li><li><code>Nsub</code>: Number of global subintervals (must satisfy the composite constraint).</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{RBig}</code>: Exact global coefficient vector <span>$\beta$</span> of length <span>$N_\text{sub}+1$</span>.</li></ul><p><strong>Errors</strong></p><ul><li>Throws (via helper checks) if the composite constraint fails or if internal assembly mismatches occur.</li></ul><p><strong>Performance notes</strong></p><ul><li>For large <code>p</code> the exact rational weights can become extremely large; this may be slow and memory-heavy even before conversion to <code>Float64</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/saintbenjamin/Maranatha.jl/blob/5a88455c9c82cb5ebc846519828a97b7044345f8/src/generator/Integrate.jl#L487-L526">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Maranatha.Integrate._check_condition-Tuple{Int64, Symbol, Int64}"><a class="docstring-binding" href="#Maranatha.Integrate._check_condition-Tuple{Int64, Symbol, Int64}"><code>Maranatha.Integrate._check_condition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_check_condition(
    p::Int, 
    boundary::Symbol, 
    Nsub::Int
) -&gt; (m, wL, wR)</code></pre><p>Validate and decode the composite tiling constraint for exact Newton-Cotes assembly.</p><p><strong>Function description</strong></p><p>The composite construction must tile the global interval <span>$[0, N_\text{sub}]$</span> (in units of <span>$h$</span>) using:</p><ul><li>one left boundary block of width <span>$w_L$</span>,</li><li><span>$m$</span> interior closed blocks each of width <span>$p-1$</span>,</li><li>one right boundary block of width <span>$w_R$</span>.</li></ul><p>The required constraint is:</p><p class="math-container">\[N_\text{sub} = w_L + m \, (p - 1) + w_R\]</p><p>where <span>$w_L$</span> / <span>$w_R$</span> depend on the boundary pattern (<code>:LCRC</code>, <code>:LORC</code>, <code>:LCRO</code>, <code>:LORO</code>).</p><p>This function checks:</p><ol><li><span>$N_\text{sub} \ge w_L + w_R$</span>, and</li><li><span>$(N_\text{sub} - w_L - w_R)$</span> divisible by <span>$(p-1)$</span>.</li></ol><p>If invalid, it throws with a message that includes nearby valid <span>$N_\text{sub}$</span> values.</p><p><strong>Arguments</strong></p><ul><li><code>p</code>: Local node count (must satisfy <span>$p \ge 2$</span>).</li><li><code>boundary</code>: Boundary pattern symbol.</li><li><code>Nsub</code>: Number of subintervals for the global composite rule (must satisfy <span>$N_\text{sub} \ge 1$</span>).</li></ul><p><strong>Returns</strong></p><ul><li><code>m::Int</code>: Number of interior closed blocks.</li><li><code>wL::Int</code>: Left block width in units of <span>$h$</span>.</li><li><code>wR::Int</code>: Right block width in units of <span>$h$</span>.</li></ul><p><strong>Errors</strong></p><ul><li>Throws (via <a href="../JobLoggerTools/#Maranatha.JobLoggerTools.error_benji"><code>Maranatha.JobLoggerTools.error_benji</code></a>) if constraints are violated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/saintbenjamin/Maranatha.jl/blob/5a88455c9c82cb5ebc846519828a97b7044345f8/src/generator/Integrate.jl#L402-L443">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Maranatha.Integrate._compute_local_alpha-Tuple{Int64, Symbol, Symbol}"><a class="docstring-binding" href="#Maranatha.Integrate._compute_local_alpha-Tuple{Int64, Symbol, Symbol}"><code>Maranatha.Integrate._compute_local_alpha</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_compute_local_alpha(
    p::Int, 
    kind::Symbol, 
    which_open::Symbol
) -&gt; (nodes, α, w_int)</code></pre><p>Compute local Newton-Cotes weights <span>$\alpha$</span> on the dimensionless interval <span>$[0, w]$</span>.</p><p><strong>Function description</strong></p><p>This helper constructs the moment-matching linear system for a local block:</p><ul><li>Choose local nodes <span>$u_j$</span> depending on <code>kind</code> / <code>which_open</code>.</li><li>Set <span>$w$</span> (in units of <span>$h$</span>) via <a href="#Maranatha.Integrate._local_width-Tuple{Int64, Symbol}"><code>_local_width</code></a><code>(p, kind)</code>.</li><li>Solve the Vandermonde-like system:</li></ul><p class="math-container">\[\sum_j \alpha_j \, u_j^k = \int\limits_0^w du \; u^k \, \quad \text{for} \quad k = 0 , \ldots , p-1\]</p><p>All computations are performed in exact rational arithmetic (<a href="#Maranatha.Integrate.RBig"><code>RBig</code></a>) so that the assembled composite weights are exact before conversion to <code>Float64</code>.</p><p><strong>Arguments</strong></p><ul><li><code>p</code>: Number of nodes in the local block (must satisfy <span>$p \ge 2$</span>).</li><li><code>kind</code>: Either <code>:closed</code> or <code>:opened</code>.</li><li><code>which_open</code>: For opened blocks, either <code>:backward</code> or <code>:forward</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>nodes::Vector{RBig}</code>: Local node positions in dimensionless units.</li><li><code>α::Vector{RBig}</code>: Exact local weights satisfying moment matching on <span>$[0, w]$</span>.</li><li><code>w_int::Int</code>: Local interval width <code>w</code> in units of <code>h</code>.</li></ul><p><strong>Errors</strong></p><ul><li>Throws (via downstream helpers) if arguments are invalid or if the solve fails.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/saintbenjamin/Maranatha.jl/blob/5a88455c9c82cb5ebc846519828a97b7044345f8/src/generator/Integrate.jl#L342-L376">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Maranatha.Integrate._decode_boundary-Tuple{Symbol}"><a class="docstring-binding" href="#Maranatha.Integrate._decode_boundary-Tuple{Symbol}"><code>Maranatha.Integrate._decode_boundary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_decode_boundary(
    boundary::Symbol
) -&gt; Tuple{Symbol,Symbol}</code></pre><p>Decode a composite boundary pattern symbol into the left/right local rule kinds.</p><p><strong>Function description</strong></p><p>This helper maps the global boundary pattern used by the exact-rational composite Newton-Cotes assembly into the <em>local</em> endpoint kinds:</p><ul><li><code>:closed</code> means the local block includes the endpoint node.</li><li><code>:opened</code> means the local block is shifted (open-type block).</li></ul><p>Supported boundary patterns are:</p><ul><li><code>:LCRC</code> (Left Closed, Right Closed)</li><li><code>:LORC</code> (Left Opened, Right Closed)</li><li><code>:LCRO</code> (Left Closed, Right Opened)</li><li><code>:LORO</code> (Left Opened, Right Opened)</li></ul><p><strong>Arguments</strong></p><ul><li><code>boundary</code>: Boundary pattern symbol.</li></ul><p><strong>Returns</strong></p><ul><li><code>(Ltype, Rtype)</code>: A tuple of symbols, each either <code>:closed</code> or <code>:opened</code>.</li></ul><p><strong>Errors</strong></p><ul><li>Throws (via <code>JobLoggerTools.error_benji</code>) if <code>boundary</code> is not one of the supported symbols.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/saintbenjamin/Maranatha.jl/blob/5a88455c9c82cb5ebc846519828a97b7044345f8/src/generator/Integrate.jl#L172-L200">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Maranatha.Integrate._exact_moment_0w-Tuple{Rational{BigInt}, Int64}"><a class="docstring-binding" href="#Maranatha.Integrate._exact_moment_0w-Tuple{Rational{BigInt}, Int64}"><code>Maranatha.Integrate._exact_moment_0w</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_exact_moment_0w(
    w::RBig, 
    k::Int
) -&gt; RBig</code></pre><p>Compute the exact monomial moment <span>$\displaystyle{\int\limits_0^w du \; u^k}$</span> as a rational number.</p><p><strong>Function description</strong></p><p>This routine returns the closed-form value</p><p class="math-container">\[\displaystyle{\int\limits_0^w du \; u^k = \frac{w^{k+1}}{k+1}}\]</p><p>using exact rational arithmetic (<a href="#Maranatha.Integrate.RBig"><code>RBig</code></a>) to avoid any rounding during the moment-matching solve for local Newton-Cotes weights.</p><p><strong>Arguments</strong></p><ul><li><code>w</code>: Upper limit of the local integration interval (dimensionless), as <a href="#Maranatha.Integrate.RBig"><code>RBig</code></a>.</li><li><code>k</code>: Monomial power (assumed <span>$k \ge 0$</span> in intended usage).</li></ul><p><strong>Returns</strong></p><ul><li><a href="#Maranatha.Integrate.RBig"><code>RBig</code></a>: The exact moment value.</li></ul><p><strong>Errors</strong></p><ul><li>No explicit checks are performed; invalid <code>k</code> may lead to unintended behavior.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/saintbenjamin/Maranatha.jl/blob/5a88455c9c82cb5ebc846519828a97b7044345f8/src/generator/Integrate.jl#L309-L334">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Maranatha.Integrate._get_beta_float-Tuple{Int64, Symbol, Int64}"><a class="docstring-binding" href="#Maranatha.Integrate._get_beta_float-Tuple{Int64, Symbol, Int64}"><code>Maranatha.Integrate._get_beta_float</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_beta_float(
    p::Int, 
    boundary::Symbol, 
    Nsub::Int
) -&gt; Vector{Float64}</code></pre><p>Get the global composite coefficient vector <span>$\beta$</span> in <code>Float64</code>, with optional caching.</p><p><strong>Function description</strong></p><p>This routine is the <code>Float64</code>-facing wrapper around the exact rational assembly:</p><ol><li>Check the cache <a href="#Maranatha.Integrate._NS_BETA_CACHE"><code>_NS_BETA_CACHE</code></a> using key <code>(p, boundary, Nsub)</code>.</li><li>If missing, build <span>$\beta$</span> exactly via <a href="#Maranatha.Integrate._assemble_composite_beta_rational-Tuple{Int64, Symbol, Int64}"><code>_assemble_composite_beta_rational</code></a>.</li><li>Convert each <a href="#Maranatha.Integrate.RBig"><code>RBig</code></a> entry to <code>Float64</code>.</li><li>Store the result in the cache and return it.</li></ol><p>The returned vector <span>$\beta$</span> has length <span>$N_\text{sub}+1$</span> and is intended to be scaled by <span>$h$</span> to produce quadrature weights <code>ws</code>.</p><p><strong>Arguments</strong></p><ul><li><code>p</code>: Local node count (must satisfy <span>$p \ge 2$</span>).</li><li><code>boundary</code>: Boundary pattern symbol (<code>:LCRC</code>, <code>:LORC</code>, <code>:LCRO</code>, <code>:LORO</code>).</li><li><code>Nsub</code>: Number of subintervals (must satisfy the composite constraint for the given boundary).</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: The coefficient vector <span>$\beta$</span> (length <span>$N_\text{sub}+1$</span>) in <code>Float64</code>.</li></ul><p><strong>Errors</strong></p><ul><li>Propagates any error from <a href="#Maranatha.Integrate._assemble_composite_beta_rational-Tuple{Int64, Symbol, Int64}"><code>_assemble_composite_beta_rational</code></a> and its validators.</li></ul><p><strong>Performance notes</strong></p><ul><li>The cache is recommended when repeatedly calling the same <code>(p, boundary, Nsub)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/saintbenjamin/Maranatha.jl/blob/5a88455c9c82cb5ebc846519828a97b7044345f8/src/generator/Integrate.jl#L655-L688">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Maranatha.Integrate._is_ns_rule-Tuple{Symbol}"><a class="docstring-binding" href="#Maranatha.Integrate._is_ns_rule-Tuple{Symbol}"><code>Maranatha.Integrate._is_ns_rule</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_is_ns_rule(
    rule::Symbol
) -&gt; Bool</code></pre><p>Return <code>true</code> if <code>rule</code> is a composite exact-assembly Newton-Cotes rule symbol of the form <code>:ns_pK</code>.</p><p><strong>Function description</strong></p><p>This helper recognizes the new composite exact-rational rules introduced in this module. A rule is considered an <em>NS rule</em> if its symbol string begins with <code>&quot;ns_p&quot;</code> (e.g. <code>:ns_p3</code>, <code>:ns_p5</code>).</p><p><strong>Arguments</strong></p><ul><li><code>rule</code>: Quadrature rule symbol.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if <code>rule</code> starts with <code>&quot;ns_p&quot;</code>, else <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/saintbenjamin/Maranatha.jl/blob/5a88455c9c82cb5ebc846519828a97b7044345f8/src/generator/Integrate.jl#L597-L613">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Maranatha.Integrate._local_nodes-Tuple{Int64, Symbol, Symbol}"><a class="docstring-binding" href="#Maranatha.Integrate._local_nodes-Tuple{Int64, Symbol, Symbol}"><code>Maranatha.Integrate._local_nodes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_local_nodes(
    p::Int, 
    kind::Symbol, 
    which_open::Symbol
) -&gt; Vector{RBig}</code></pre><p>Construct the local node positions (dimensionless <code>u</code>) for a Newton-Cotes block.</p><p><strong>Function description</strong></p><p>This helper produces the exact (rational) node locations used to solve for the local quadrature weights <span>$\alpha$</span> via moment matching.</p><ul><li>For <code>kind == :closed</code>, nodes are <code>u = 0:(p-1)</code> (length <code>p</code>).</li><li>For <code>kind == :opened</code>, nodes depend on the direction:<ul><li><code>which_open == :backward</code>: <code>u = 1:p</code> (left-opened style)</li><li><code>which_open == :forward</code> : <code>u = 0:(p-1)</code> (right-opened style)</li></ul></li></ul><p>All nodes are returned as <code>RBig = Rational{BigInt}</code> to support exact assembly.</p><p><strong>Arguments</strong></p><ul><li><code>p</code>: Number of nodes (must satisfy <span>$p \ge 2$</span>).</li><li><code>kind</code>: Either <code>:closed</code> or <code>:opened</code>.</li><li><code>which_open</code>: For opened blocks, either <code>:backward</code> or <code>:forward</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{RBig}</code>: Local nodes in dimensionless units.</li></ul><p><strong>Errors</strong></p><ul><li>Throws (via <code>JobLoggerTools.error_benji</code>) if <span>$p &lt; 2$</span>, <code>kind</code> is invalid, or <code>which_open</code> is not one of <code>:backward</code> / <code>:forward</code> when needed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/saintbenjamin/Maranatha.jl/blob/5a88455c9c82cb5ebc846519828a97b7044345f8/src/generator/Integrate.jl#L255-L286">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Maranatha.Integrate._local_width-Tuple{Int64, Symbol}"><a class="docstring-binding" href="#Maranatha.Integrate._local_width-Tuple{Int64, Symbol}"><code>Maranatha.Integrate._local_width</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_local_width(
    p::Int, 
    kind::Symbol
) -&gt; Int</code></pre><p>Return the local block width in units of <span>$h$</span> for a Newton-Cotes block of order <span>$p$</span>.</p><p><strong>Function description</strong></p><p>In the exact-rational composite assembly, each local Newton-Cotes block covers a domain <span>$[0, w]$</span> in dimensionless units, where <span>$w$</span> depends on whether the block is closed or opened:</p><ul><li>closed block: <span>$w = p - 1$</span></li><li>opened block: <span>$w = p$</span></li></ul><p>This width is used to enforce the composite tiling constraint and to build the exact moment vector on <span>$[0, w]$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>p</code>: Number of nodes in the local Newton-Cotes block (must satisfy <span>$p \ge 2$</span>).</li><li><code>kind</code>: Either <code>:closed</code> or <code>:opened</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: The local width <code>w</code> in units of <code>h</code>.</li></ul><p><strong>Errors</strong></p><ul><li>Throws (via <a href="../JobLoggerTools/#Maranatha.JobLoggerTools.error_benji"><code>Maranatha.JobLoggerTools.error_benji</code></a>) if <code>kind</code> is unknown.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/saintbenjamin/Maranatha.jl/blob/5a88455c9c82cb5ebc846519828a97b7044345f8/src/generator/Integrate.jl#L217-L245">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Maranatha.Integrate._parse_ns_p-Tuple{Symbol}"><a class="docstring-binding" href="#Maranatha.Integrate._parse_ns_p-Tuple{Symbol}"><code>Maranatha.Integrate._parse_ns_p</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_parse_ns_p(
    rule::Symbol
) -&gt; Int</code></pre><p>Parse the local node count <code>p</code> from an NS rule symbol <code>:ns_pK</code>.</p><p><strong>Function description</strong></p><p>For composite exact-assembly Newton-Cotes rules, the rule symbol encodes the local node count <code>p</code> as:</p><pre><code class="language-julia hljs">:ns_p3, :ns_p4, :ns_p5, ...</code></pre><p>This function extracts and validates <code>p</code> from the symbol.</p><p><strong>Arguments</strong></p><ul><li><code>rule</code>: Quadrature rule symbol, expected to start with <code>&quot;ns_p&quot;</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: Parsed node count <code>p</code> (guaranteed <span>$p \ge 2$</span> if successful).</li></ul><p><strong>Errors</strong></p><ul><li>Throws (via <a href="../JobLoggerTools/#Maranatha.JobLoggerTools.error_benji"><code>Maranatha.JobLoggerTools.error_benji</code></a>) if the symbol does not start with <code>&quot;ns_p&quot;</code> or if the parsed <code>p</code> is invalid.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/saintbenjamin/Maranatha.jl/blob/5a88455c9c82cb5ebc846519828a97b7044345f8/src/generator/Integrate.jl#L620-L644">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Maranatha.Integrate.integrate-NTuple{7, Any}"><a class="docstring-binding" href="#Maranatha.Integrate.integrate-NTuple{7, Any}"><code>Maranatha.Integrate.integrate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">integrate(
    integrand,
    a,
    b,
    N,
    dim,
    rule,
    boundary
) -&gt; Float64</code></pre><p>Evaluate a tensor-product Newton-Cotes quadrature on the hypercube <span>$[a,b]^{\texttt{dim}}$</span>.</p><p><strong>Function description</strong></p><p>This function serves as the unified integration dispatcher within the <code>Maranatha.jl</code> pipeline.</p><ol><li>It builds the <strong>1D nodes and weights</strong> for the selected Newton-Cotes <code>rule</code> on <span>$[a,b]$</span> with resolution <code>N</code>.</li><li>It evaluates the <strong>tensor-product quadrature</strong> in <code>dim</code> dimensions by enumerating the multi-index over the 1D nodes and accumulating the weighted sum of <span>$\texttt{integrand}(x_1,\,\ldots,\,x_{\texttt{dim}})$</span>.</li></ol><p>The same bounds <span>$[a,b]$</span> are applied along every axis, i.e. the integration domain is <span>$[a,b]^{\texttt{dim}}$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>integrand</code>: A callable that accepts exactly <code>dim</code> positional arguments (function, closure, or callable struct).</li><li><code>a</code>, <code>b</code>: Lower/upper bounds applied to every axis.</li><li><code>N</code>: Number of subintervals per axis (rule-specific constraints apply).</li><li><code>dim</code>: Dimensionality (must satisfy <code>dim ≥ 1</code>).</li><li><code>rule</code>: Quadrature rule symbol (e.g. <code>:simpson13_close</code>, <code>:simpson38_open</code>, <code>:bode_close</code>, ...).</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Estimated integral value.</li></ul><p><strong>Errors</strong></p><ul><li>Throws an error if <code>dim &lt; 1</code>.</li><li>Throws an error if <code>rule</code> is unknown or if <code>N</code> violates rule-specific constraints.</li><li>Any error thrown by <code>integrand</code> during evaluation is propagated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/saintbenjamin/Maranatha.jl/blob/5a88455c9c82cb5ebc846519828a97b7044345f8/src/generator/Integrate.jl#L24-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Maranatha.Integrate.integrate_1d-NTuple{6, Any}"><a class="docstring-binding" href="#Maranatha.Integrate.integrate_1d-NTuple{6, Any}"><code>Maranatha.Integrate.integrate_1d</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">integrate_1d(
    f, 
    a, 
    b, 
    N, 
    rule,
    boundary
) -&gt; Float64</code></pre><p>Evaluate the <span>$1$</span>-dimensional integral of <span>$f(x)$</span> over <span>$[a, b]$</span> using a tensor-product quadrature constructed from 1D nodes and weights.</p><p><strong>Function description</strong></p><p>This routine generates 1D quadrature nodes and weights using <a href="#Maranatha.Integrate.quadrature_1d_nodes_weights-Tuple{Real, Real, Int64, Symbol, Symbol}"><code>quadrature_1d_nodes_weights</code></a><code>(a, b, N, rule, boundary)</code> and computes:</p><p class="math-container">\[\sum_i w_i \, f(x_i) \,.\]</p><p>This keeps all rule-specific constraints and behaviour centralized in <a href="#Maranatha.Integrate.quadrature_1d_nodes_weights-Tuple{Real, Real, Int64, Symbol, Symbol}"><code>quadrature_1d_nodes_weights</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Integrand callable <code>f(x)</code>.</li><li><code>a</code>, <code>b</code>: Integration bounds.</li><li><code>N</code>: Number of intervals (rule-specific constraints are enforced by <a href="#Maranatha.Integrate.quadrature_1d_nodes_weights-Tuple{Real, Real, Int64, Symbol, Symbol}"><code>quadrature_1d_nodes_weights</code></a>).</li><li><code>rule</code>: Integration rule symbol.</li><li><code>boundary</code>: Boundary pattern symbol (<code>:LCRC</code>, <code>:LORC</code>, <code>:LCRO</code>, <code>:LORO</code>). Required for NS rules.</li></ul><p><strong>Returns</strong></p><ul><li>Estimated integral value as a <code>Float64</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/saintbenjamin/Maranatha.jl/blob/5a88455c9c82cb5ebc846519828a97b7044345f8/src/generator/Integrate/integrate_1d.jl#L11-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Maranatha.Integrate.integrate_2d-NTuple{6, Any}"><a class="docstring-binding" href="#Maranatha.Integrate.integrate_2d-NTuple{6, Any}"><code>Maranatha.Integrate.integrate_2d</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">integrate_2d(
    f, 
    a, 
    b, 
    N, 
    rule,
    boundary
) -&gt; Float64</code></pre><p>Evaluate a <span>$2$</span>-dimensional integral of <span>$f(x, y)$</span> over the square domain <span>$[a, b] \times [a, b]$</span> using a tensor-product quadrature constructed from 1D nodes and weights.</p><p><strong>Function description</strong></p><p>This routine generates 1D quadrature nodes and weights using <a href="#Maranatha.Integrate.quadrature_1d_nodes_weights-Tuple{Real, Real, Int64, Symbol, Symbol}"><code>quadrature_1d_nodes_weights</code></a><code>(a, b, N, rule, boundary)</code> and forms the tensor product:</p><p class="math-container">\[\sum_i \sum_j w_i w_j \, f(x_i, y_j) \,.\]</p><p>Loop ordering and accumulation are preserved exactly as implemented.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Integrand callable <code>f(x, y)</code>.</li><li><code>a</code>, <code>b</code>: Square domain bounds (used for both axes).</li><li><code>N</code>: Number of intervals per axis.</li><li><code>rule</code>: Integration rule symbol.</li><li><code>boundary</code>: Boundary pattern symbol (<code>:LCRC</code>, <code>:LORC</code>, <code>:LCRO</code>, <code>:LORO</code>). Required for NS rules.</li></ul><p><strong>Returns</strong></p><ul><li>Estimated integral value as a <code>Float64</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/saintbenjamin/Maranatha.jl/blob/5a88455c9c82cb5ebc846519828a97b7044345f8/src/generator/Integrate/integrate_2d.jl#L11-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Maranatha.Integrate.integrate_3d-NTuple{6, Any}"><a class="docstring-binding" href="#Maranatha.Integrate.integrate_3d-NTuple{6, Any}"><code>Maranatha.Integrate.integrate_3d</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">integrate_3d(
    f, 
    a, 
    b, 
    N, 
    rule,
    boundary
) -&gt; Float64</code></pre><p>Evaluate a <span>$3$</span>-dimensional integral of <span>$f(x, y, z)$</span> over the cube domain <code>[a, b]^3</code> using a tensor-product quadrature constructed from 1D nodes and weights.</p><p><strong>Function description</strong></p><p>This routine generates 1D quadrature nodes and weights using <a href="#Maranatha.Integrate.quadrature_1d_nodes_weights-Tuple{Real, Real, Int64, Symbol, Symbol}"><code>quadrature_1d_nodes_weights</code></a><code>(a, b, N, rule)</code> and forms the tensor product:</p><p class="math-container">\[\sum_i \sum_j \sum_k w_i w_j w_k \, f(x_i, y_j, z_k) \,.\]</p><p>Loop ordering and accumulation are preserved exactly as implemented.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Integrand callable <code>f(x, y, z)</code>.</li><li><code>a</code>, <code>b</code>: Cube domain bounds (used for all axes).</li><li><code>N</code>: Number of intervals per axis.</li><li><code>rule</code>: Integration rule symbol.</li><li><code>boundary</code>: Boundary pattern symbol (<code>:LCRC</code>, <code>:LORC</code>, <code>:LCRO</code>, <code>:LORO</code>). Required for NS rules.</li></ul><p><strong>Returns</strong></p><ul><li>Estimated integral value as a <code>Float64</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/saintbenjamin/Maranatha.jl/blob/5a88455c9c82cb5ebc846519828a97b7044345f8/src/generator/Integrate/integrate_3d.jl#L11-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Maranatha.Integrate.integrate_4d-NTuple{6, Any}"><a class="docstring-binding" href="#Maranatha.Integrate.integrate_4d-NTuple{6, Any}"><code>Maranatha.Integrate.integrate_4d</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">integrate_4d(
    f, 
    a, 
    b, 
    N, 
    rule,
    boundary
) -&gt; Float64</code></pre><p>Evaluate a <span>$4$</span>-dimensional integral of <span>$f(x, y, z, t)$</span> over the hypercube domain <code>[a, b]^4</code> using a tensor-product quadrature constructed from 1D nodes and weights.</p><p><strong>Function description</strong></p><p>This routine generates 1D quadrature nodes and weights using <a href="#Maranatha.Integrate.quadrature_1d_nodes_weights-Tuple{Real, Real, Int64, Symbol, Symbol}"><code>quadrature_1d_nodes_weights</code></a><code>(a, b, N, rule, boundary)</code> and forms the tensor product:</p><p class="math-container">\[\sum_i \sum_j \sum_k \sum_\ell w_i w_j w_k w_\ell \, f(x_i, y_j, z_k, t_\ell) \,.\]</p><p>Loop ordering and accumulation are preserved exactly as implemented.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Integrand callable <code>f(x, y, z, t)</code>.</li><li><code>a</code>, <code>b</code>: Hypercube domain bounds (used for all axes).</li><li><code>N</code>: Number of intervals per axis.</li><li><code>rule</code>: Integration rule symbol.</li><li><code>boundary</code>: Boundary pattern symbol (<code>:LCRC</code>, <code>:LORC</code>, <code>:LCRO</code>, <code>:LORO</code>). Required for NS rules.</li></ul><p><strong>Returns</strong></p><ul><li>Estimated integral value as a <code>Float64</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/saintbenjamin/Maranatha.jl/blob/5a88455c9c82cb5ebc846519828a97b7044345f8/src/generator/Integrate/integrate_4d.jl#L11-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Maranatha.Integrate.integrate_nd-NTuple{6, Any}"><a class="docstring-binding" href="#Maranatha.Integrate.integrate_nd-NTuple{6, Any}"><code>Maranatha.Integrate.integrate_nd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">integrate_nd(
    f,
    a,
    b,
    N,
    rule,
    boundary;
    dim::Int
) -&gt; Float64</code></pre><p>Perform an <strong>multidimensional tensor-product quadrature</strong> over the hypercube domain <span>$[a,b]^{\texttt{dim}}$</span> using a 1D rule specified by <code>rule</code>.</p><p><strong>Function description</strong></p><p>This routine evaluates a multidimensional integral by constructing the tensor product of a 1D quadrature rule.</p><p>The algorithm:</p><ol><li><p>Builds 1D quadrature nodes and weights <code>(xs, ws)</code> via <a href="#Maranatha.Integrate.quadrature_1d_nodes_weights-Tuple{Real, Real, Int64, Symbol, Symbol}"><code>quadrature_1d_nodes_weights</code></a><code>(a, b, N, rule, boundary)</code>.</p></li><li><p>Iterates over all multi-indices <span>$(i_1, i_2, \ldots, i_{\texttt{dim}})$</span> using an odometer-style index update.</p></li><li><p>Forms the tensor-product weight</p><p><span>$w =  \texttt{ws[}\texttt{i}_\texttt{1}\texttt{]} \ast \texttt{ws[}\texttt{i}_\texttt{2}\texttt{]} \ast \ldots \ast  \texttt{ws[}\texttt{i}_\texttt{dim}\texttt{]}$</span>.</p></li><li><p>Evaluates the integrand as</p><p><span>$f\texttt{(} \texttt{xs[}\texttt{i}_\texttt{1}\texttt{]},\, \texttt{xs[}\texttt{i}_\texttt{2}\texttt{]},\, \ldots,\, \texttt{xs[}\texttt{i}_\texttt{dim}\texttt{]} \texttt{)} \,.$</span></p></li><li><p>Accumulates the weighted sum</p><p><span>$\displaystyle{\sum_{i_1,\ldots,i_{\texttt{dim}}} w \ast f\texttt{(}\ldots\texttt{)}}$</span>.</p></li></ol><p>This implementation intentionally mirrors the explicit loop ordering and accumulation style used throughout the <code>Maranatha.jl</code> quadrature stack to ensure reproducibility and consistent floating-point behavior.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Integrand callable accepting <code>dim</code> scalar arguments.</li><li><code>a</code>, <code>b</code>: Domain bounds defining the hypercube <span>$[a,b]^\texttt{dim}$</span>.</li><li><code>N</code>: Number of subdivisions per axis used to build the 1D rule.</li><li><code>rule</code>: Integration rule symbol (e.g., <code>:simpson13_close</code>, <code>:bode_open</code>, etc.).</li><li><code>boundary</code>: Boundary pattern symbol (<code>:LCRC</code>, <code>:LORC</code>, <code>:LCRO</code>, <code>:LORO</code>). Required for NS rules.</li><li><code>dim</code>: Number of dimensions (must satisfy <code>dim</code><span>$\ge 1$</span>).</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Numerical quadrature estimate of the integral.</li></ul><p><strong>Notes</strong></p><ul><li>This is a pure tensor-product construction; computational cost scales as <span>$O(\texttt{length(xs)}^\texttt{dim})$</span> and therefore grows exponentially with <code>dim</code>.</li><li>Rule-specific constraints on <code>N</code> are enforced inside <a href="#Maranatha.Integrate.quadrature_1d_nodes_weights-Tuple{Real, Real, Int64, Symbol, Symbol}"><code>quadrature_1d_nodes_weights</code></a>.</li><li>The integrand is called as <span>$f(x_1, x_2, \ldots, x_\texttt{dim})$</span> using splatting.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/saintbenjamin/Maranatha.jl/blob/5a88455c9c82cb5ebc846519828a97b7044345f8/src/generator/Integrate/integrate_nd.jl#L11-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Maranatha.Integrate.quadrature_1d_nodes_weights-Tuple{Real, Real, Int64, Symbol, Symbol}"><a class="docstring-binding" href="#Maranatha.Integrate.quadrature_1d_nodes_weights-Tuple{Real, Real, Int64, Symbol, Symbol}"><code>Maranatha.Integrate.quadrature_1d_nodes_weights</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">quadrature_1d_nodes_weights(
    a::Real, 
    b::Real, 
    N::Int, 
    rule::Symbol, 
    boundary::Symbol
) -&gt; (xs, ws)</code></pre><p>Construct <span>$1$</span>-dimensional quadrature nodes and weights on <span>$[a, b]$</span> for composite Newton-Cotes rules.</p><p><strong>Function description</strong></p><p>This function is the public <span>$1$</span>-dimensional node/weight generator used by the integration dispatchers.</p><p>It supports:</p><p><strong>Composite exact-assembly rules <code>:ns_pK</code></strong></p><p>If <code>rule</code> is recognized as an NS rule, this routine:</p><ol><li>Parses <code>p</code> from <code>rule</code>,</li><li>Builds (or fetches) the coefficient vector <code>β</code> for <code>(p, boundary, N)</code>,</li><li>Forms nodes <span>$\texttt{xs}_j = a + j \, h$</span> for <span>$j = 0 , \ldots , N$</span>,</li><li>Forms weights <span>$\texttt{ws}_j = \beta_j \, h$</span>, where <span>$\displaystyle{h = \frac{b-a}{N}}$</span>.</li></ol><p>The return types are <code>Vector{Float64}</code> for both nodes and weights.</p><p><strong>Arguments</strong></p><ul><li><code>a</code>, <code>b</code>: Lower/upper bounds of the 1D interval.</li><li><code>N</code>: Number of subintervals (must satisfy <span>$N \ge 1$</span> and composite constraints for the selected boundary).</li><li><code>rule</code>: Rule symbol. Supported:<ul><li>New rules: <code>:ns_p3</code>, <code>:ns_p4</code>, <code>:ns_p5</code>, ...</li></ul></li><li><code>boundary</code>: Boundary pattern symbol (<code>:LCRC</code>, <code>:LORC</code>, <code>:LCRO</code>, <code>:LORO</code>). Required for NS rules.</li></ul><p><strong>Returns</strong></p><ul><li><code>xs::Vector{Float64}</code>: Nodes of length <span>$N+1$</span>.</li><li><code>ws::Vector{Float64}</code>: Weights of length <span>$N+1$</span>.</li></ul><p><strong>Errors</strong></p><ul><li>Throws <code>ArgumentError</code> if <span>$N &lt; 1$</span>.</li><li>Throws (via <a href="../JobLoggerTools/#Maranatha.JobLoggerTools.error_benji"><code>Maranatha.JobLoggerTools.error_benji</code></a>) if <code>boundary</code> is invalid, if the composite constraint fails, or if <code>rule</code> is unsupported.</li></ul><p><strong>Notes</strong></p><ul><li>This function currently errors on non-NS rules unless you extend the fallback branch with your pre-existing implementation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/saintbenjamin/Maranatha.jl/blob/5a88455c9c82cb5ebc846519828a97b7044345f8/src/generator/Integrate.jl#L708-L753">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Integrands/">« Integrands</a><a class="docs-footer-nextpage" href="../ErrorEstimator/">ErrorEstimator »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Saturday 28 February 2026 13:26">Saturday 28 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
