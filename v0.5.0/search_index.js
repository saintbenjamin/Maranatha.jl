var documenterSearchIndex = {"docs":
[{"location":"lib/Integrate/#Maranatha.Integrate","page":"Integrate","title":"Maranatha.Integrate","text":"","category":"section"},{"location":"lib/Integrate/#Maranatha.Integrate.integrate-NTuple{6, Any}","page":"Integrate","title":"Maranatha.Integrate.integrate","text":"integrate(\n    integrand,\n    a,\n    b,\n    N,\n    dim,\n    rule\n) -> Float64\n\nEvaluate a tensor-product Newton-Cotes quadrature on the hypercube ab^textttdim.\n\nFunction description\n\nThis function serves as the unified integration dispatcher within the Maranatha.jl pipeline.\n\nIt builds the 1D nodes and weights for the selected Newton-Cotes rule on ab with resolution N.\nIt evaluates the tensor-product quadrature in dim dimensions by enumerating the multi-index over the 1D nodes and accumulating the weighted sum of textttintegrand(x_1ldotsx_textttdim).\n\nThe same bounds ab are applied along every axis, i.e. the integration domain is ab^textttdim.\n\nArguments\n\nintegrand: A callable that accepts exactly dim positional arguments (function, closure, or callable struct).\na, b: Lower/upper bounds applied to every axis.\nN: Number of subintervals per axis (rule-specific constraints apply).\ndim: Dimensionality (must satisfy dim ≥ 1).\nrule: Quadrature rule symbol (e.g. :simpson13_close, :simpson38_open, :bode_close, ...).\n\nReturns\n\nFloat64: Estimated integral value.\n\nErrors\n\nThrows an error if dim < 1.\nThrows an error if rule is unknown or if N violates rule-specific constraints.\nAny error thrown by integrand during evaluation is propagated.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate.integrate_1d-NTuple{5, Any}","page":"Integrate","title":"Maranatha.Integrate.integrate_1d","text":"integrate_1d(\n    f, \n    a, \n    b, \n    N, \n    rule\n) -> Float64\n\nEvaluate the 1-dimensional integral of f(x) over a b using a tensor-product quadrature constructed from 1D nodes and weights.\n\nFunction description\n\nThis routine generates 1D quadrature nodes and weights using quadrature_1d_nodes_weights(a, b, N, rule) and computes:\n\nsum_i w_i  f(x_i) \n\nThis keeps all rule-specific constraints and behaviour centralized in quadrature_1d_nodes_weights.\n\nArguments\n\nf: Integrand callable f(x).\na, b: Integration bounds.\nN: Number of intervals (rule-specific constraints are enforced by quadrature_1d_nodes_weights).\nrule: Integration rule symbol.\n\nReturns\n\nEstimated integral value as a Float64.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate.integrate_2d-NTuple{5, Any}","page":"Integrate","title":"Maranatha.Integrate.integrate_2d","text":"integrate_2d(\n    f, \n    a, \n    b, \n    N, \n    rule\n) -> Float64\n\nEvaluate a 2-dimensional integral of f(x y) over the square domain a b times a b using a tensor-product quadrature constructed from 1D nodes and weights.\n\nFunction description\n\nThis routine generates 1D quadrature nodes and weights using quadrature_1d_nodes_weights(a, b, N, rule) and forms the tensor product:\n\nsum_i sum_j w_i w_j  f(x_i y_j) \n\nLoop ordering and accumulation are preserved exactly as implemented.\n\nArguments\n\nf: Integrand callable f(x, y).\na, b: Square domain bounds (used for both axes).\nN: Number of intervals per axis.\nrule: Integration rule symbol.\n\nReturns\n\nEstimated integral value as a Float64.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate.integrate_3d-NTuple{5, Any}","page":"Integrate","title":"Maranatha.Integrate.integrate_3d","text":"integrate_3d(\n    f, \n    a, \n    b, \n    N, \n    rule\n) -> Float64\n\nEvaluate a 3-dimensional integral of f(x y z) over the cube domain [a, b]^3 using a tensor-product quadrature constructed from 1D nodes and weights.\n\nFunction description\n\nThis routine generates 1D quadrature nodes and weights using quadrature_1d_nodes_weights(a, b, N, rule) and forms the tensor product:\n\nsum_i sum_j sum_k w_i w_j w_k  f(x_i y_j z_k) \n\nLoop ordering and accumulation are preserved exactly as implemented.\n\nArguments\n\nf: Integrand callable f(x, y, z).\na, b: Cube domain bounds (used for all axes).\nN: Number of intervals per axis.\nrule: Integration rule symbol.\n\nReturns\n\nEstimated integral value as a Float64.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate.integrate_4d-NTuple{5, Any}","page":"Integrate","title":"Maranatha.Integrate.integrate_4d","text":"integrate_4d(\n    f, \n    a, \n    b, \n    N, \n    rule\n) -> Float64\n\nEvaluate a 4-dimensional integral of f(x y z t) over the hypercube domain [a, b]^4 using a tensor-product quadrature constructed from 1D nodes and weights.\n\nFunction description\n\nThis routine generates 1D quadrature nodes and weights using quadrature_1d_nodes_weights(a, b, N, rule) and forms the tensor product:\n\nsum_i sum_j sum_k sum_ell w_i w_j w_k w_ell  f(x_i y_j z_k t_ell) \n\nLoop ordering and accumulation are preserved exactly as implemented.\n\nArguments\n\nf: Integrand callable f(x, y, z, t).\na, b: Hypercube domain bounds (used for all axes).\nN: Number of intervals per axis.\nrule: Integration rule symbol.\n\nReturns\n\nEstimated integral value as a Float64.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate.integrate_nd-NTuple{5, Any}","page":"Integrate","title":"Maranatha.Integrate.integrate_nd","text":"integrate_nd(\n    f,\n    a,\n    b,\n    N,\n    rule;\n    dim::Int\n) -> Float64\n\nPerform an multidimensional tensor-product quadrature over the hypercube domain ab^textttdim using a 1D rule specified by rule.\n\nFunction description\n\nThis routine evaluates a multidimensional integral by constructing the tensor product of a 1D quadrature rule.\n\nThe algorithm:\n\nBuilds 1D quadrature nodes and weights (xs, ws) via quadrature_1d_nodes_weights(a, b, N, rule).\nIterates over all multi-indices (i_1 i_2 ldots i_textttdim) using an odometer-style index update.\nForms the tensor-product weight\nw =  textttwstexttti_texttt1texttt ast textttwstexttti_texttt2texttt ast ldots ast  textttwstexttti_textttdimtexttt.\nEvaluates the integrand as\nftexttt( textttxstexttti_texttt1texttt textttxstexttti_texttt2texttt ldots textttxstexttti_textttdimtexttt texttt) \nAccumulates the weighted sum\ndisplaystylesum_i_1ldotsi_textttdim w ast ftexttt(ldotstexttt).\n\nThis implementation intentionally mirrors the explicit loop ordering and accumulation style used throughout the Maranatha.jl quadrature stack to ensure reproducibility and consistent floating-point behavior.\n\nArguments\n\nf: Integrand callable accepting dim scalar arguments.\na, b: Domain bounds defining the hypercube ab^textttdim.\nN: Number of subdivisions per axis used to build the 1D rule.\nrule: Integration rule symbol (e.g., :simpson13_close, :bode_open, etc.).\ndim: Number of dimensions (must satisfy dim ≥ 1).\n\nReturns\n\nFloat64: Numerical quadrature estimate of the integral.\n\nNotes\n\nThis is a pure tensor-product construction; computational cost scales as O(textttlength(xs)^textttdim) and therefore grows exponentially with dim.\nRule-specific constraints on N are enforced inside quadrature_1d_nodes_weights.\nThe integrand is called as f(x_1 x_2  x_textttdim) using splatting.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate/#Maranatha.Integrate.quadrature_1d_nodes_weights-Tuple{Real, Real, Int64, Symbol}","page":"Integrate","title":"Maranatha.Integrate.quadrature_1d_nodes_weights","text":"quadrature_1d_nodes_weights(\n    a::Real, \n    b::Real, \n    N::Int, \n    rule::Symbol\n) -> Tuple{Vector{Float64}, Vector{Float64}}\n\nGenerate 1D quadrature nodes and weights for a Newton-Cotes rule on a b.\n\nFunction description\n\nThis function constructs the node vector xs and weight vector ws for the specified rule over the interval a b using a uniform step size displaystyleh = fracb-aN. The returned (xs, ws) pair is suitable for building tensor-product quadrature rules in higher dimensions.\n\nBoth closed rules (including endpoints) and the opened rules (excluding endpoints) are supported. The implementation preserves the exact node ordering and weight construction used by the original code.\n\nArguments\n\na, b: Integration bounds.\nN: Number of intervals defining the uniform grid spacing displaystyleh = fracb-aN.\nrule: Quadrature rule symbol:\nClosed composite rules: :simpson13_close, :simpson38_close, :bode_close\nOpened composite rules: :simpson13_open, :simpson38_open, :bode_open\n\nReturns\n\nxs::Vector{Float64}: Quadrature nodes (in the exact order they are pushed).\nws::Vector{Float64}: Corresponding quadrature weights (already scaled by h and any rule-specific prefactors).\n\nErrors\n\nThrows an error if rule is not recognized.\nThrows an error if N violates rule-specific constraints (divisibility and/or minimum N).\n\n\n\n\n\n","category":"method"},{"location":"lib/PlotTools/#Maranatha.PlotTools","page":"PlotTools","title":"Maranatha.PlotTools","text":"","category":"section"},{"location":"lib/PlotTools/#Maranatha.PlotTools.plot_convergence_result-Tuple{String, Vector{Float64}, Vector{Float64}, Vector{Float64}, Any}","page":"PlotTools","title":"Maranatha.PlotTools.plot_convergence_result","text":"plot_convergence_result(\n    name::String,\n    hs::Vector{Float64},\n    estimates::Vector{Float64},\n    errors::Vector{Float64},\n    fit_result;\n    rule::Symbol = :simpson13_close\n) -> Nothing\n\nPlot convergence data I(h) against h^2, overlay the fitted extrapolation curve, and visualize the fit uncertainty band propagated from the parameter covariance.\n\nFunction description\n\nThis routine is a visualization companion to Maranatha.FitConvergence.fit_convergence. It produces a publication-style convergence plot and saves it as a PNG file.\n\nThe x-axis is h^2 (with displaystyleh = fracb-aN supplied via hs), and the y-axis is the raw integral estimate I(h) with its pointwise error bar.\n\nA convergence model is reconstructed from the fit parameters under the rule-dependent leading power p:\n\nI(h) = I_0 + C_1  h^p + C_2  h^p+2 + C_3  h^p+4 + ldots\n\nwhere I_0 is the extrapolated h to 0 limit.\n\nFit curve and uncertainty band\n\nThis function does not refit anything. It uses the stored fit output:\n\npvec = fit_result.params\nCov  = fit_result.cov\n\nFor each point on a dense grid in h, it builds the basis vector\n\nvarphi(h) =\nbeginbmatrix\n1  h^p  h^p+2  cdots\nendbmatrix^mathsfT\n\nand evaluates:\n\nfit curve: I_textfit(h) = bmlambda cdot bmvarphi(h)\n1  sigma fit uncertainty (where V is covariance matrix):\n\nsigma_textfit(h)^2 = varphi(h)^mathsfT  V  varphi(h)\n\nThe plotted shaded band corresponds to I_textfit(h) pm sigma_textfit(h), and therefore includes parameter correlations.\n\nPlot elements\n\nThe resulting figure contains:\n\nthe fitted curve I_textfit(h) (line),\nthe fit uncertainty band pm sigma (shaded region),\nthe measured points with error bars,\nthe extrapolated point at h^2 = 0 with uncertainty fit_result.estimate_error.\n\nThe output file is saved as:\n\nconvergence_<name>_<rule>.png\n\nArguments\n\nname: Label used in the output filename.\nhs: Step sizes h (typically displaystyleh = fracb-aN).\nestimates: Quadrature estimates I(h) corresponding to hs.\nerrors: Error estimates for I(h) (absolute values are used for plotting).\nfit_result: Fit object expected to provide:\nfit_result.params\nfit_result.cov\nfit_result.estimate\nfit_result.estimate_error\n\nKeyword arguments\n\nrule: Quadrature rule symbol used to determine the leading power p and to label the output filename.\n\nReturns\n\nnothing.\n\nErrors\n\nThrows an error if input lengths mismatch.\nThrows an error if no valid points remain after filtering.\nThrows an error if rule is not recognized.\n\n\n\n\n\n","category":"method"},{"location":"lib/PlotTools/#Maranatha.PlotTools.set_pyplot_latex_style","page":"PlotTools","title":"Maranatha.PlotTools.set_pyplot_latex_style","text":"set_pyplot_latex_style(\n    scale::Float64=0.5\n) -> Nothing\n\nConfigure PyPlot.jl with LaTeX rendering and appropriate font settings for publications.\n\nThis function modifies matplotlib.rcParams to enable LaTeX-based text rendering and adjust  font sizes, marker sizes, and line widths for consistent visual output.   Useful for generating high-quality plots for papers or presentations.\n\nArguments\n\nscale::Float64: Scaling factor for font sizes and figure dimensions. Default is 0.5.\n\nSide Effects\n\nModifies PyPlot.jl's global rendering configuration via matplotlib.rcParams.\n\n\n\n\n\n","category":"function"},{"location":"lib/RichardsonError/#Maranatha.RichardsonError","page":"RichardsonError","title":"Maranatha.RichardsonError","text":"","category":"section"},{"location":"lib/RichardsonError/#Maranatha.RichardsonError.estimate_error_richardson-Tuple{Any, Any, Any, Int64, Int64, Symbol}","page":"RichardsonError","title":"Maranatha.RichardsonError.estimate_error_richardson","text":"estimate_error_richardson(\n    integrand, \n    a, \n    b, \n    N::Int, \n    dim::Int, \n    rule::Symbol\n) -> Float64\n\nEstimate the integration error using a Richardson-based scale comparison between resolutions N and 2N.\n\nFunction description\n\nThis estimator evaluates the integral twice using the same rule:\n\nI(N)  with resolution N\nI(2N) with resolution 2N\n\nAssuming a leading-order error scaling of O(h^p), the Richardson estimate is\n\nerr ≈ |I(2N) - I(N)| / (2^p - 1)\n\nwhere p = rule_order(rule).\n\nThis implementation intentionally preserves the exact call order and floating-point behavior of the original version.\n\nArguments\n\nintegrand: Function representing the integrand. Must accept dim positional arguments.\na, b: Scalar bounds defining the hypercube [a,b]^dim.\nN: Base resolution (number of subintervals per axis).\ndim: Number of dimensions (forwarded to integrate_nd).\nrule: Integration rule symbol.\n\nReturns\n\nA Float64 Richardson-style error scale computed from I(N) and I(2N).\n\nNotes\n\nThis provides an error scale rather than a strict bound.\nAny rule-specific constraints on N (e.g., divisibility) must be satisfied by both N and 2N.\n\n\n\n\n\n","category":"method"},{"location":"lib/RichardsonError/#Maranatha.RichardsonError.rule_order-Tuple{Symbol}","page":"RichardsonError","title":"Maranatha.RichardsonError.rule_order","text":"rule_order(\n    rule::Symbol\n) -> Int\n\nReturn the leading convergence order p of the specified Newton–Cotes rule, assuming an asymptotic error scaling of O(h^p).\n\nFunction description\n\nThis function maps each supported integration rule to its expected leading error order used in Richardson extrapolation. The mapping is intentionally kept identical to the original implementation so that numerical behavior remains unchanged.\n\nArguments\n\nrule: Integration rule symbol.\n\nSupported rules and orders\n\n:simpson13_close → p = 4\n:simpson38_close → p = 4\n:bode_close      → p = 6\n:simpson13_open  → p = 4\n:simpson38_open  → p = 4\n:bode_open       → p = 6\n\nReturns\n\nInteger convergence order p.\n\nErrors\n\nThrows an error if rule is not supported.\n\n\n\n\n\n","category":"method"},{"location":"lib/BodeRule/#Maranatha.BodeRule","page":"BodeRule","title":"Maranatha.BodeRule","text":"","category":"section"},{"location":"lib/BodeRule/#Maranatha.BodeRule.bode_rule-Tuple{Any, Real, Real, Int64}","page":"BodeRule","title":"Maranatha.BodeRule.bode_rule","text":"bode_rule(\n    f, \n    a::Real, \n    b::Real, \n    N::Int\n) -> Float64\n\nNumerically integrate a 1D function f(x) over [a, b] using the composite Bode’s rule (closed 5-point Newton–Cotes; 4 subintervals per block).\n\nFunction description\n\nThis function applies the composite Bode’s rule by partitioning the interval [a, b] into N uniform subintervals with spacing h = (b-a)/N, where N must be divisible by 4. The integral is computed as a sum over N/4 non-overlapping blocks, each spanning 4 subintervals (5 grid points) with weights:\n\n[7, 32, 12, 32, 7].\n\nThe implementation preserves the original evaluation order and arithmetic.\n\nArguments\n\nf: Integrand callable of one variable f(x) (function, closure, or callable struct).\na::Real: Lower integration limit.\nb::Real: Upper integration limit.\nN::Int: Number of subintervals (must be divisible by 4).\n\nReturns\n\nEstimated value of the definite integral of f(x) over [a, b] as a Float64.\n\nNotes\n\nStep size: h = (b - a) / N.\nNumber of blocks: nblocks = N ÷ 4.\nEach block contributes: 7 f(x0) + 32 f(x1) + 12 f(x2) + 32 f(x3) + 7 f(x4), with xj = a + (4k + j) h for j = 0..4.\nComposite scaling factor: (2h/45).\n\nErrors\n\nThrows an error if N is not divisible by 4.\n\n\n\n\n\n","category":"method"},{"location":"lib/BodeRule_MinOpen_MaxOpen/#Maranatha.BodeRule*MinOpen*MaxOpen","page":"BodeRuleMinOpenMaxOpen","title":"Maranatha.BodeRuleMinOpenMaxOpen","text":"","category":"section"},{"location":"lib/BodeRule_MinOpen_MaxOpen/#Maranatha.BodeRule_MinOpen_MaxOpen.bode_rule_min_open_max_open-Tuple{Any, Real, Real, Int64}","page":"BodeRuleMinOpenMaxOpen","title":"Maranatha.BodeRule_MinOpen_MaxOpen.bode_rule_min_open_max_open","text":"bode_rule_min_open_max_open(\n    f, \n    a::Real, \n    b::Real, \n    N::Int\n) -> Float64\n\nNumerically integrate a 1D function f(x) over [a, b] using a globally-open (endpoint-free) composite Boole rule (a.k.a. Bode/Boole) on a uniform grid.\n\nFunction description\n\nThis rule approximates the definite integral on [a, b] using only interior samples f(x1), ..., f(x_{N-1}), i.e. it never evaluates the integrand at the endpoints x0 = a or xN = b.\n\nGrid convention:\n\nh  = (b - a)/N\nxj = a + j*h, for j = 0,1,...,N.\n\nConstruction summary (degree-5 exactness):\n\nStart from the standard composite closed Boole rule, which is exact for polynomials up to degree 5.\nEliminate the endpoint samples f(x0) and f(xN) using 5th-degree Lagrange extrapolation expressed in terms of the first/last six interior nodes:\nf(x0) from x1..x6\nf(xN) from x_{N-1}..x_{N-6}\n\nThe resulting endpoint-eliminated rule remains degree-5 exact while being globally endpoint-free. The implementation preserves the original evaluation order and arithmetic.\n\nArguments\n\nf: Integrand callable of one variable f(x) (function, closure, or callable struct).\na::Real: Lower integration bound.\nb::Real: Upper integration bound.\nN::Int: Number of subintervals (must satisfy the constraints below).\n\nReturns\n\nEstimated value of the definite integral over [a, b] as a Float64.\n\nConstraints\n\nN must be divisible by 4 (Boole panels are 4 subintervals wide).\nN ≥ 16 so that the left/right 6-point endpoint stencils do not overlap.\n\nNotes\n\nBase interior weights (from the closed composite Boole rule) depend on j mod 4:\nj mod 4 == 1 or 3 → 64/45\nj mod 4 == 2      → 8/15\nj mod 4 == 0      → 28/45  (interior panel boundaries)\nendpoints j=0,N would be 14/45, but they are not sampled here.\nEndpoint elimination uses coefficients (6, -15, 20, -15, 6, -1) applied to the first/last six interior nodes.\n\nErrors\n\nThrows an error if N is not divisible by 4 or if N < 16.\n\n\n\n\n\n","category":"method"},{"location":"lib/Simpson13Rule_MinOpen_MaxOpen/#Maranatha.Simpson13Rule*MinOpen*MaxOpen","page":"Simpson13RuleMinOpenMaxOpen","title":"Maranatha.Simpson13RuleMinOpenMaxOpen","text":"","category":"section"},{"location":"lib/Simpson13Rule_MinOpen_MaxOpen/#Maranatha.Simpson13Rule_MinOpen_MaxOpen.simpson13_rule_min_open_max_open-Tuple{Any, Real, Real, Int64}","page":"Simpson13RuleMinOpenMaxOpen","title":"Maranatha.Simpson13Rule_MinOpen_MaxOpen.simpson13_rule_min_open_max_open","text":"simpson13_rule_min_open_max_open(\n    f, \n    a::Real, \n    b::Real, \n    N::Int\n) -> Float64\n\nNumerically integrate a 1D function f(x) over [a, b] using a globally-open (endpoint-free) composite Simpson 1/3 \"open-chain\" rule.\n\nFunction description\n\nThis rule approximates the definite integral over [a, b] using only interior grid samples and never evaluates the integrand at the endpoints x0 = a or xN = b. The grid is defined by\n\nh  = (b - a)/N\nxj = a + j*h, for j = 0,1,...,N.\n\nThe quadrature is exact for polynomials up to degree 3 and uses the stencil\n\n∫ f(x) dx ≈ h * [\n(9/4)   f(x1)   + (13/12) f(x3)\n\n* (4/3)   Σ f(xj) for even j = 4,6,...,N-4\n* (2/3)   Σ f(xj) for odd  j = 5,7,...,N-5\n* (13/12) f(x_{N-3}) + (9/4) f(x_{N-1})\n  ]\n\nThe implementation preserves the original evaluation order and arithmetic.\n\nArguments\n\nf: Integrand callable of one variable f(x) (function, closure, or callable struct).\na::Real: Lower integration bound.\nb::Real: Upper integration bound.\nN::Int: Number of subintervals (must satisfy the constraints below).\n\nReturns\n\nEstimated value of the definite integral over [a, b] as a Float64.\n\nConstraints\n\nN must be even.\nN ≥ 8 (smallest size where the open-chain pattern is well-defined).\n\nNotes\n\nEndpoint values f(a) and f(b) are never evaluated.\nThe rule uses asymmetric weights near the boundaries to maintain global degree-3 exactness while remaining endpoint-free.\n\nErrors\n\nThrows an error if N is not even or if N < 8.\n\n\n\n\n\n","category":"method"},{"location":"lib/JobLoggerTools/#Maranatha.JobLoggerTools","page":"JobLoggerTools","title":"Maranatha.JobLoggerTools","text":"","category":"section"},{"location":"lib/JobLoggerTools/#Maranatha.JobLoggerTools.assert_benji","page":"JobLoggerTools","title":"Maranatha.JobLoggerTools.assert_benji","text":"assert_benji(\n    cond::Bool, \n    msg::AbstractString, \n    jobid::Union{Nothing, String}=nothing\n) -> Nothing\n\nAssert that cond is true. If false, log an error with timestamp and job ID, then throw.\n\nArguments\n\ncond: Boolean condition to assert.\nmsg: Message to print if assertion fails.\njobid: Optional job identifier.\n\n\n\n\n\n","category":"function"},{"location":"lib/JobLoggerTools/#Maranatha.JobLoggerTools.debug_benji","page":"JobLoggerTools","title":"Maranatha.JobLoggerTools.debug_benji","text":"debug_benji(\n    msg::AbstractString, \n    jobid::Union{Nothing, String}=nothing\n) -> Nothing\n\nPrint a timestamped debug message with optional job ID.\n\nThe message is prefixed with [DEBUG], and flushed to stdout.\n\nArguments\n\nmsg: Debug message to print.\njobid: Optional job identifier.\n\n\n\n\n\n","category":"function"},{"location":"lib/JobLoggerTools/#Maranatha.JobLoggerTools.error_benji","page":"JobLoggerTools","title":"Maranatha.JobLoggerTools.error_benji","text":"error_benji(\n    msg::AbstractString, \n    jobid::Union{Nothing, String}=nothing\n) -> Nothing\n\nPrint an error message with timestamp and job ID (if given), then throw an error with the same message.\n\nAlso flushes stdout and stderr after printing.\n\n\n\n\n\n","category":"function"},{"location":"lib/JobLoggerTools/#Maranatha.JobLoggerTools.info_benji","page":"JobLoggerTools","title":"Maranatha.JobLoggerTools.info_benji","text":"info_benji(\n    msg::AbstractString, \n    jobid::Union{Nothing, String}=nothing\n) -> Nothing\n\nPrint a timestamped informational message with optional job ID.\n\nThe message is prefixed with [INFO], and flushed to stdout.\n\nArguments\n\nmsg: Informational message to print.\njobid: Optional job identifier.\n\n\n\n\n\n","category":"function"},{"location":"lib/JobLoggerTools/#Maranatha.JobLoggerTools.log_stage_benji","page":"JobLoggerTools","title":"Maranatha.JobLoggerTools.log_stage_benji","text":"log_stage_benji(\n    title::String, \n    jobid::Union{Nothing, String}=nothing\n) -> Nothing\n\nPrint a high-level stage delimiter with a title, surrounded by = lines.\n\nUseful for separating major processing stages in logs.\n\n\n\n\n\n","category":"function"},{"location":"lib/JobLoggerTools/#Maranatha.JobLoggerTools.log_stage_sub1_benji","page":"JobLoggerTools","title":"Maranatha.JobLoggerTools.log_stage_sub1_benji","text":"log_stage_sub1_benji(\n    title::String, \n    jobid::Union{Nothing, String}=nothing\n) -> Nothing\n\nPrint a substage delimiter with a title, surrounded by - lines.\n\nUsed for visually marking sub-sections in logs.\n\n\n\n\n\n","category":"function"},{"location":"lib/JobLoggerTools/#Maranatha.JobLoggerTools.println_benji","page":"JobLoggerTools","title":"Maranatha.JobLoggerTools.println_benji","text":"println_benji(\n    msg::AbstractString, \n    jobid::Union{Nothing, String}=nothing\n) -> Nothing\n\nPrint a timestamped log message with optional job ID.\n\nArguments\n\nmsg: The message to print.\njobid: Optional job identifier to prepend.\n\nOutput is printed to stdout, immediately flushed.\n\n\n\n\n\n","category":"function"},{"location":"lib/JobLoggerTools/#Maranatha.JobLoggerTools.warn_benji","page":"JobLoggerTools","title":"Maranatha.JobLoggerTools.warn_benji","text":"warn_benji(\n    msg::AbstractString, \n    jobid::Union{Nothing, String}=nothing\n) -> Nothing\n\nPrint a timestamped warning message with optional job ID.\n\nThe message is prefixed with [WARNING], and flushed to stdout.\n\nArguments\n\nmsg: Warning message to print.\njobid: Optional job identifier.\n\n\n\n\n\n","category":"function"},{"location":"lib/JobLoggerTools/#Maranatha.JobLoggerTools.@logtime_benji-Tuple{Any, Any}","page":"JobLoggerTools","title":"Maranatha.JobLoggerTools.@logtime_benji","text":"@logtime_benji(\n    jobid_expr, \n    expr\n) -> Any\n\nMacro that times and logs the execution of an expression, with optional GC allocation info.\n\nArguments\n\njobid_expr: Optional job ID (can be nothing).\nexpr: Any Julia expression to execute and time.\n\nLogs elapsed time and memory usage with a timestamp. Returns the value of expr.\n\n\n\n\n\n","category":"macro"},{"location":"lib/Simpson13Rule/#Maranatha.Simpson13Rule","page":"Simpson13Rule","title":"Maranatha.Simpson13Rule","text":"","category":"section"},{"location":"lib/Simpson13Rule/#Maranatha.Simpson13Rule.simpson13_rule-Tuple{Any, Float64, Real, Int64}","page":"Simpson13Rule","title":"Maranatha.Simpson13Rule.simpson13_rule","text":"simpson13_rule(\n    f, \n    a::Float64, \n    b::Real, \n    N::Int\n) -> Float64\n\nNumerically integrate a 1D function f(x) over [a, b] using the composite Simpson’s 1/3 rule.\n\nFunction description\n\nThis function applies the composite Simpson 1/3 Newton–Cotes quadrature rule on a uniform grid of N subintervals. The endpoint contributions are weighted by 1, odd interior points are weighted by 4, and even interior points are weighted by 2:\n\n[1, 4, 2, 4, ..., 2, 4, 1].\n\nThe implementation preserves the original evaluation order and arithmetic.\n\nArguments\n\nf: Integrand callable of one variable f(x) (function, closure, or callable struct).\na::Float64: Lower integration limit.\nb::Real: Upper integration limit.\nN::Int: Number of subintervals (must be divisible by 2).\n\nReturns\n\nEstimated value of the definite integral of f(x) over [a, b] as a Float64.\n\nNotes\n\nThe grid spacing is h = (b - a)/N.\nThe grid nodes are constructed as x[i] = a + (i-1)*h for i = 1..N+1.\nThis is a 4th-order accurate method for sufficiently smooth integrands under the standard composite Simpson assumptions.\n\nErrors\n\nThrows an error if N is not divisible by 2.\n\n\n\n\n\n","category":"method"},{"location":"lib/Simpson38Rule/#Maranatha.Simpson38Rule","page":"Simpson38Rule","title":"Maranatha.Simpson38Rule","text":"","category":"section"},{"location":"lib/Simpson38Rule/#Maranatha.Simpson38Rule.simpson38_rule-Tuple{Any, Real, Real, Int64}","page":"Simpson38Rule","title":"Maranatha.Simpson38Rule.simpson38_rule","text":"simpson38_rule(\n    f, \n    a::Real, \n    b::Real, \n    N::Int\n) -> Float64\n\nNumerically integrate a 1D function f(x) over [a, b] using the composite Simpson’s 3/8 rule (closed Newton–Cotes with a repeated 4-point stencil).\n\nFunction description\n\nThis function applies the composite Simpson 3/8 rule on a uniform grid of N subintervals (so the node spacing is h = (b-a)/N). The rule requires N to be divisible by 3 and uses weights:\n\nendpoints: weight 1,\ninterior points: weight 2 if the index is a multiple of 3, otherwise 3.\n\nThe implementation preserves the original evaluation order and arithmetic.\n\nArguments\n\nf: Integrand callable of one variable f(x) (function, closure, or callable struct).\na::Real: Lower integration limit.\nb::Real: Upper integration limit.\nN::Int: Number of subintervals (must be divisible by 3).\n\nReturns\n\nEstimated value of the definite integral of f(x) over [a, b] as a Float64.\n\nNotes\n\nThe step size is h = (b - a) / N.\nThe composite scaling factor is (3h/8).\nThis method is 4th-order accurate for sufficiently smooth integrands under the standard composite Simpson assumptions.\n\nErrors\n\nThrows an error if N is not divisible by 3.\n\n\n\n\n\n","category":"method"},{"location":"lib/Simpson38Rule_MinOpen_MaxOpen/#Maranatha.Simpson38Rule*MinOpen*MaxOpen","page":"Simpson38RuleMinOpenMaxOpen","title":"Maranatha.Simpson38RuleMinOpenMaxOpen","text":"","category":"section"},{"location":"lib/Simpson38Rule_MinOpen_MaxOpen/#Maranatha.Simpson38Rule_MinOpen_MaxOpen.simpson38_rule_min_open_max_open-Tuple{Any, Real, Real, Int64}","page":"Simpson38RuleMinOpenMaxOpen","title":"Maranatha.Simpson38Rule_MinOpen_MaxOpen.simpson38_rule_min_open_max_open","text":"simpson38_rule_min_open_max_open(\n    f, \n    a::Real, \n    b::Real, \n    N::Int\n) -> Float64\n\nNumerically integrate a 1D function f(x) over [a, b] using an endpoint-free (\"open\") chained 3-point Newton–Cotes composite rule on a uniform grid.\n\nFunction description\n\nThis is a truly endpoint-free open Newton–Cotes rule that tiles the full interval by panels of width 4h. Each panel k approximates the integral on [x_{4k}, x_{4k+4}] using only the interior nodes x_{4k+1}, x_{4k+2}, x_{4k+3} (no endpoint evaluations on panel boundaries).\n\nThe uniform grid is defined by:\n\nh = (b - a)/N\nx_j = a + j*h, for j = 0,1,...,N.\n\nThe quadrature is:\n\n∫*{x0}^{xN} f(x) dx ≈ h * Σ*{k=0..M-1} [\n(8/3) f(x_{4k+1}) - (4/3) f(x_{4k+2}) + (8/3) f(x_{4k+3})\n]\n\nwith N = 4M.\n\nThe implementation preserves the original evaluation order and arithmetic.\n\nArguments\n\nf: Integrand callable of one variable f(x) (function, closure, or callable struct).\na::Real: Lower integration bound.\nb::Real: Upper integration bound.\nN::Int: Number of subintervals (must satisfy the constraints below).\n\nReturns\n\nEstimated value of the definite integral over [a, b] as a Float64.\n\nConstraints\n\nN must be divisible by 4.\nN ≥ 4.\n\nNotes\n\nThe rule is endpoint-free: it does not evaluate f(a) or f(b), and also does not evaluate the panel boundary nodes x_{4k} and x_{4k+4}.\nThe panel width is exactly 4h, so the number of panels is M = N ÷ 4.\n\nErrors\n\nThrows an error if N is not divisible by 4 or if N < 4.\n\n\n\n\n\n","category":"method"},{"location":"lib/FitConvergence/#Maranatha.FitConvergence","page":"FitConvergence","title":"Maranatha.FitConvergence","text":"","category":"section"},{"location":"lib/FitConvergence/#Maranatha.FitConvergence.fit_convergence-Tuple{Any, Any, Any, Symbol}","page":"FitConvergence","title":"Maranatha.FitConvergence.fit_convergence","text":"fit_convergence(\n    hs,\n    estimates,\n    errors,\n    rule::Symbol;\n    nterms::Int = 2\n)\n\nPerform a h to 0 (zero step-size limit) extrapolation using least-chi^2 fitting for the quadrature estimate, and return both best-fit parameters and their uncertainties.\n\nFunction description\n\nThis routine fits a rule-dependent convergence ansatz that is linear in its parameters, using weighted least squares (WLS). The step size is provided by the caller as displaystyleh = fracb-aN (via hs), and the leading convergence power p is inferred from the chosen quadrature rule.\n\nThe convergence model is selected by the number of basis terms nterms (including the constant term). The design matrix is constructed as:\n\ncolumn 1: h^0 (constant term)\ncolumns 2..nterms: h^p, h^(p+2), h^(p+4), ...\n\nEquivalently, the fitted form is:\n\nI(h) = I_0 + C_1  h^p + C_2  h^p+2 + C_3  h^p+4 + ldots\n\nSolve (WLS)\n\nLet X be the design matrix, y the estimates, and sigma the pointwise errors. Weights are constructed as W = sigma_ii^-1, and the WLS normal equations are solved in the numerically stable form:\n\nleft( W X right)  bmlambda = left( W  y right) \n\nyielding displaystylebmlambda = beginbmatrix I_0  C_1  C_2  cdots endbmatrix^mathsfT.\n\nParameter covariance and errors\n\nThis implementation computes Hessian-based propagation, but evaluates the needed inverse-Hessian actions via a Cholesky factorization rather than forming inv(H) explicitly.\n\nBuild the normal matrix A = X^mathsfT  W^2  X.\nDefine the χ² Hessian as H = 2A.\nFactorize the Hessian H = L  L^mathsfT via cholesky(Symmetric(H)) (requires Symmetric Positive Definite (SPD)).\nDefine H^-1 implicitly through linear solves with the Cholesky factor.\nThe parameter covariance matrix V is then taken as\n\nV = Delta = 4  H^-1  A  H^-1 \n\nand the 1  sigma errors of fitting parameters are sqrtdiag(V).\n\nWhy H = 2  A?\n\nFor the WLS objective chi^2(bmlambda) = leftlvert W left( X  bmlambda - mathbfy right) rightrvert^2, the gradient is nabla chi^2 = 2 X^mathsfT  W^2  left( X  bmlambda - mathbfy right) and the Hessian is nabla^2 chi^2 = 2 X^mathsfT  W^2  X = 2  A. So this factor of 2 is exact for this model.\n\nNotes:\n\nIf you prefer the standard WLS covariance (Gauss-Markov for linear models), you can instead use V = left( X^mathsfT  W^2  X right)^-1.\nThe returned cov is intended for downstream use (e.g. to draw a fit-band via sigma_textfit^2(h) = varphi(h)^mathsfT  V  varphi(h)).\n\nArguments\n\nhs: Vector-like collection of step sizes displaystyleh = fracb-aN.\nestimates: Vector-like collection of quadrature estimates I(h).\nerrors: Vector-like collection of error estimates associated with I(h).\nrule: Quadrature rule symbol used to select the leading convergence power p.\n\nKeyword arguments\n\nnterms::Int=2: Number of basis terms in the convergence model (including the constant term). Must satisfy ntermsge 2.\n\nReturns\n\nA NamedTuple with the following fields:\n\nestimate::Float64: Extrapolated value I_0 = I(h to 0) (i.e. params[1]).\nestimate_error::Float64: One-sigma uncertainty for I_0, taken from the covariance diagonal.\nparams::Vector{Float64}: Fitted parameter vector [I0, C1, C2, ...].\nparam_errors::Vector{Float64}: 1  sigma uncertainties for params.\ncov::Matrix{Float64}: Parameter covariance matrix.\nchisq::Float64: chi^2 value.\nredchisq::Float64: chi^2textdof.\ndof::Int: Degrees of freedom, length(y) - length(params).\n\nErrors\n\nThrows an error if rule is not recognized.\nThrows an error if nterms < 2.\nThrows an error if the Hessian is not positive definite (Cholesky fails).\nNote: If dof == 0, redchisq will be Inf/NaN depending on chisq.\n\n\n\n\n\n","category":"method"},{"location":"lib/FitConvergence/#Maranatha.FitConvergence.print_fit_result-Tuple{Any}","page":"FitConvergence","title":"Maranatha.FitConvergence.print_fit_result","text":"print_fit_result(\n    fit\n) -> Nothing\n\nPrint a formatted summary of a convergence fit result.\n\nFunction description\n\nThis routine prints each fitted parameter λ_k with its one-sigma uncertainty using AvgErrFormatter.avgerr_e2d_from_float, followed by χ² diagnostics and the extrapolated result I(h→0).\n\nThe output formatting and ordering are intentionally kept identical to the original implementation.\n\nArguments\n\nfit: Fit result object (typically the NamedTuple returned by fit_convergence) that provides the fields:\nparams\nparam_errors\nchisq\ndof\nredchisq\nestimate\nestimate_error\n\nReturns\n\nnothing.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrate_legacy/#Maranatha.Integrate-(Legacy)","page":"Integrate (Legacy)","title":"Maranatha.Integrate (Legacy)","text":"","category":"section"},{"location":"lib/Integrate_legacy/#Maranatha.Integrate.integrate_1d_legacy-NTuple{5, Any}","page":"Integrate (Legacy)","title":"Maranatha.Integrate.integrate_1d_legacy","text":"integrate_1d_legacy(\n    f, \n    a, \n    b, \n    N, \n    rule\n) -> Float64\n\nEvaluate a 1-dimensional integral of f(x) over a b using the specified quadrature rule.\n\nFunction description\n\nThis function dispatches to the dedicated 1D implementations for each supported Newton-Cotes rule. Both closed and open-chain variants are supported.\n\nArguments\n\nf: Integrand function f(x).\na, b: Integration bounds.\nN: Number of intervals (rule-specific divisibility/minimum constraints apply).\nrule: Integration rule symbol.\n\nReturns\n\nEstimated integral value as a Float64.\n\nErrors\n\nThrows an error if rule is not recognized.\n\n\n\n\n\n","category":"method"},{"location":"lib/Runner/#Maranatha.Runner","page":"Runner","title":"Maranatha.Runner","text":"","category":"section"},{"location":"lib/Runner/#Maranatha.Runner.run_Maranatha-Tuple{Any, Any, Any}","page":"Runner","title":"Maranatha.Runner.run_Maranatha","text":"run_Maranatha(\n    integrand,\n    a,\n    b;\n    dim=1,\n    nsamples=[4,8,16],\n    rule=:simpson13_close,\n    err_method::Symbol=:derivative,\n    fit_terms::Int=2\n)\n\nHigh-level execution pipeline for n-dimensional quadrature, error modeling, and convergence extrapolation.\n\nFunction description\n\nrun_Maranatha is the orchestration entry point that combines the core subsystems of Maranatha:\n\nMaranatha.Integrate      : tensor-product Newton-Cotes quadrature in arbitrary dimension\nMaranatha.ErrorEstimator : derivative-based error scale models\nMaranatha.FitConvergence : least-χ² fitting for h to 0 extrapolation\n\nFor each resolution N in nsamples, the runner performs:\n\nCompute step size\nh = fracb-aN  \nEvaluate the integral using the selected rule via Maranatha.Integrate.integrate.\nEstimate the integration error according to err_method.\nAccumulate (h, estimate, error) triplets.\n\nAfter processing all resolutions, a weighted convergence fit is performed:\n\nI(h) = I_0 + C_1  h^p + C_2  h^p+2 + \n\nwhere the leading power p is determined from rule.\n\nThe final extrapolated estimate I_0 is returned together with the full fit object and the raw data vectors used in the fit.\n\nArguments\n\nintegrand: Callable integrand. May be a function, closure, or callable struct. Must accept dim scalar positional arguments.\na, b: Scalar bounds defining the hypercube domain ab^n where n is (spacetime) dimensionality.\n\nKeyword arguments\n\ndim::Int=1: Dimensionality of the tensor-product quadrature. Internally dispatched through Maranatha.Integrate.integrate,  which supports specialized implementations (from 1-dimensional to 4-dimensional quadrature) and a general n-dimensional quadrature fallback.\nnsamples=[4,8,16]: Vector of subdivision counts N. Each value defines a different grid resolution used in the convergence study.\nrule::Symbol=:simpson13_close: Newton-Cotes rule identifier forwarded to both integration and error estimation modules.\nerr_method::Symbol=:derivative: Error estimation strategy. Supported values:\n:derivative  → Maranatha.ErrorEstimator.estimate_error\n:richardson  → Maranatha.RichardsonError.estimate_error_richardson\nfit_terms::Int=2: Number of basis terms used in the convergence model (including the constant extrapolated value).\n\nReturns\n\nA 3-tuple:\n\nfinal_estimate::Float64: Convenience alias for fit_result.estimate.\nfit_result::NamedTuple: Fit object returned by Maranatha.FitConvergence.fit_convergence.   Fields:\nestimate::Float64 : Extrapolated integral estimate I_0 (the h to 0 limit), equal to params[1].\nestimate_error::Float64 : 1  sigma uncertainty of estimate, taken as param_errors[1] from the covariance diagonal.\nparams::Vector{Float64} : Fitted parameter vector I_0 C_1 C_2 ldots for the model I(h) = I_0 + C_1 h^p + C_2 h^p+2 + cdots.\nparam_errors::Vector{Float64} : 1  sigma uncertainties for params (square roots of diag(cov)).\ncov::Matrix{Float64} : Parameter covariance matrix, suitable for uncertainty propagation (e.g. sigma_mathrmfit(h)^2 = phi(h)^topVphi(h) where V is covariance matrix).\nchisq::Float64 : Total chi-square value \nchi^2 = sum_i left(fracy_i - hat y_isigma_iright)^2 \nredchisq::Float64 : Reduced chi-square chi^2mathrmdof. (If dof == 0, this may be Inf/NaN depending on chisq.)\ndof::Int : Degrees of freedom length(estimates) - length(params).\ndata::NamedTuple: Raw convergence data:\nh   : step sizes\navg : integral estimates\nerr : error estimates\n\nDesign notes\n\nThe runner is dimension-agnostic: the tensor-product implementation allows arbitrary n ge 1 (n: dimension), subject only to computational cost.\nError estimators provide a scale model rather than a strict truncation bound, enabling stable weighted fits across dimensions.\nLogging and timing are fully centralized through Maranatha.JobLoggerTools.\n\nExample\n\nf(x, y, z, t) = sin(x * y^3 * z * t) * exp(x^2)\n\nI0, fit, data = run_Maranatha(\n    f, \n    0.0, 1.0;\n    dim=4,\n    nsamples=[40, 44, 48, 52, 56, 60, 64],\n    rule=:bode_close,\n    err_method=:derivative\n    fit_terms=4\n)\n\n\n\n\n\n","category":"method"},{"location":"lib/Z_q/#Maranatha.Z_q","page":"Z_q","title":"Maranatha.Z_q","text":"","category":"section"},{"location":"lib/ErrorEstimator_legacy/#Maranatha.ErrorEstimator-(Legacy)","page":"ErrorEstimator (Legacy)","title":"Maranatha.ErrorEstimator (Legacy)","text":"","category":"section"},{"location":"lib/ErrorEstimator_legacy/#Maranatha.ErrorEstimator.estimate_error_1d_legacy-Tuple{Any, Real, Real, Int64, Symbol}","page":"ErrorEstimator (Legacy)","title":"Maranatha.ErrorEstimator.estimate_error_1d_legacy","text":"estimate_error_1d_legacy(\n    f, \n    a::Real, \n    b::Real, \n    N::Int, \n    rule::Symbol\n) -> Float64\n\nEstimate the integration error for a 1D integral of f(x) over [a, b] using rule-dependent, derivative-based heuristics designed to match the lightweight, unified tensor-error philosophy used in higher dimensions.\n\nFunction description\n\nThis estimator intentionally prioritizes:\n\nspeed (few derivative evaluations),\nstable scaling with step size h = (b-a)/N,\nconsistent behavior across dimensions (1D/2D/3D/4D),\n\nrather than reproducing the full composite-rule truncation expansions.\n\nIn particular:\n\nThe closed rules use a single midpoint derivative as a leading-term model.\nThe open-chain rules use lightweight leading-term models:\nsome are boundary-difference dominated (endpoint stencil effect),\nsome use a single midpoint derivative with the tensor-error coefficient.\n\nThese estimates are used as error scales for fitting/extrapolation, not as rigorous bounds.\n\nArguments\n\nf: Scalar-to-scalar integrand callable f(x) (function, closure, or callable struct).\na, b: Integration limits (scalars).\nN: Number of subintervals (must satisfy rule-specific constraints).\nrule: Integration rule symbol:\n:simpson13_close → closed composite Simpson 1/3 (midpoint 4th-derivative heuristic)\n:simpson38_close → closed composite Simpson 3/8 (midpoint 4th-derivative heuristic)\n:bode_close      → closed composite Bode/Boole (midpoint 6th-derivative heuristic)\n:simpson13_open  → open-chain Simpson 1/3 (boundary 3rd-derivative difference heuristic)\n:simpson38_open  → open 3-point chained rule, panels of width 4h                       (midpoint 4th-derivative heuristic with coefficient 14/45)\n:bode_open       → open-chain Boole-type rule (boundary 5th-derivative difference heuristic)\n\nReturns\n\nA Float64 heuristic error estimate (signed), interpreted as an estimate of (exact - quadrature) in the same sign convention as the implemented formula. If rule is not recognized, returns 0.0.\n\nErrors\n\nThrows an error if N violates rule-specific constraints.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrands/#Maranatha.Integrands","page":"Integrands","title":"Maranatha.Integrands","text":"","category":"section"},{"location":"lib/Integrands/#Maranatha.Integrands.available_integrands-Tuple{}","page":"Integrands","title":"Maranatha.Integrands.available_integrands","text":"available_integrands()\n\nReturn the list of currently registered integrand names.\n\nReturns\n\nVector{Symbol}: Registered integrand keys.\n\nNotes\n\nThe order of the returned symbols follows the iteration order of the internal dictionary and is not guaranteed to be stable across Julia versions.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrands/#Maranatha.Integrands.integrand-Tuple{Symbol}","page":"Integrands","title":"Maranatha.Integrands.integrand","text":"integrand(\n    name::Symbol; \n    kwargs...\n)\n\nConstruct a callable integrand from the registry.\n\nFunction description\n\nThis function looks up name in the integrand registry and invokes the corresponding factory with the provided keyword arguments. The result is a callable object that can be passed directly into Maranatha.Runner.run_Maranatha.\n\nArguments\n\nname::Symbol: Integrand identifier registered via register_integrand!.\n\nKeyword arguments\n\nkwargs...: Keyword arguments forwarded to the registered factory.\n\nReturns\n\nA callable integrand object returned by the registered factory.\n\nErrors\n\nThrows an error if name is not registered.\n\n\n\n\n\n","category":"method"},{"location":"lib/Integrands/#Maranatha.Integrands.register_integrand!-Tuple{Symbol, Function}","page":"Integrands","title":"Maranatha.Integrands.register_integrand!","text":"register_integrand!(\n    name::Symbol, \n    factory::Function\n)\n\nRegister a new integrand factory into the Maranatha.jl integrand registry.\n\nFunction description\n\nThis function associates an integrand name name with a factory function factory. The factory must accept keyword arguments and return a callable integrand object (e.g., a closure or a callable struct).\n\nOnce registered, the integrand can be constructed via:\n\nintegrand(name; kwargs...).\n\nArguments\n\nname::Symbol: Integrand identifier used as the registry key.\nfactory::Function: Factory function of the form factory(; kwargs...) -> f, where f is callable.\n\nReturns\n\nnothing\n\nNotes\n\nRe-registering an existing name overwrites the prior factory.\nThe registry is stored as a module-level constant dictionary to keep lookup/dispatch lightweight.\n\n\n\n\n\n","category":"method"},{"location":"man/Maranatha/#Maranatha-Module","page":"Maranatha Module","title":"Maranatha Module","text":"To be updated.","category":"section"},{"location":"lib/F0000GammaEminus1/#Maranatha.F0000GammaEminus1","page":"F0000GammaEminus1","title":"Maranatha.F0000GammaEminus1","text":"","category":"section"},{"location":"lib/F0000GammaEminus1/#Maranatha.F0000GammaEminus1.exI0_safe-Tuple{T} where T<:Number","page":"F0000GammaEminus1","title":"Maranatha.F0000GammaEminus1.exI0_safe","text":"exI0_safe(\n    x::T\n) where {T<:Number}\n\nCompute exp(-x) * I0(x) (modified Bessel I0) in an overflow-safe manner.\n\nFunction description\n\nThis helper evaluates the scaled Bessel factor exp(-x) * besseli(0, x) that appears in the F0000 integrand.\n\nFor small to moderate x, it computes the expression directly.\nFor large x, it switches to an asymptotic series for exp(-x) I0(x) to avoid overflow in besseli(0, x) while preserving the intended scaling.\n\nArguments\n\nx::T: Input value (intended usage: x ≥ 0).\n\nReturns\n\nT: The value of exp(-x) * I0(x).\n\nNotes\n\nThe branch threshold x ≤ 50 is a Float64-oriented \"safe zone\" heuristic and is kept identical to the original implementation for reproducibility.\nThe asymptotic series used is: exp(-x) I0(x) ≈ 1/sqrt(2πx) * (1 + 1/(8x) + 9/(128x^2) + 225/(3072x^3) + 11025/(98304x^4)). This is a truncated large-x expansion and is not a strict error bound.\nThe implementation is written to accept generic Number inputs so it can work with AD / Taylor objects when needed.\n\nErrors\n\nNo explicit domain checks are performed. If x is negative, the asymptotic branch is not mathematically intended and may produce complex values due to the square root.\n\n\n\n\n\n","category":"method"},{"location":"lib/F0000GammaEminus1/#Maranatha.F0000GammaEminus1.g_F0000_raw-Tuple{T} where T<:Number","page":"F0000GammaEminus1","title":"Maranatha.F0000GammaEminus1.g_F0000_raw","text":"g_F0000_raw(\n    y::T\n) where {T<:Number}\n\nEvaluate the raw integrand g_F0000_raw(y) used in the F0000 computation for y ∈ (0, 1).\n\nFunction description\n\nThis function maps\n\nx = (1 - y) / y  (so x > 0 for 0 < y < 1),\n\nthen forms the raw integrand as the sum of two pieces:\n\ntermA: proportional to (exp(-x) I0(x))^4 with a rational prefactor in y,\ntermB: a correction term involving exp(-x/2) and a rational prefactor in y.\n\nThe algebraic form is preserved exactly from the original implementation.\n\nArguments\n\ny::T: Real input (intended usage: 0 < y < 1).\n\nReturns\n\nT: Raw integrand value at y.\n\nNotes\n\nThis raw form contains endpoint-singular prefactors such as 1/y^3 and 1/(y*(1-y)). It is therefore intended to be evaluated away from y = 0, 1. Endpoint suppression / regularization is handled in gtilde_F0000 via the t-space cutoff.\nThe implementation accepts generic Number to support AD / Taylor fallbacks.\n\nErrors\n\nNo explicit domain checks are performed. Passing y ≤ 0 or y ≥ 1 can lead to division by zero or non-finite values.\n\n\n\n\n\n","category":"method"},{"location":"lib/F0000GammaEminus1/#Maranatha.F0000GammaEminus1.gtilde_F0000-Tuple{T} where T<:Number","page":"F0000GammaEminus1","title":"Maranatha.F0000GammaEminus1.gtilde_F0000","text":"gtilde_F0000(\n    t::T; \n    p::Int=2, \n    eps::T=T(1e-15)\n) where {T<:Number}\n\nReturn the transformed integrand g̃(t) for the F0000 integral after the variable substitution y = t^p on the interval t ∈ [0, 1].\n\nFunction description\n\nThis routine wraps g_F0000_raw(y) by applying:\n\nsubstitution: y = t^p with integer p ≥ 1,\nJacobian: dy = p * t^(p-1) dt,\n\nso the returned transformed integrand is:\n\ng̃(t) = p * t^(p-1) * g_F0000_raw(t^p).\n\nTo avoid endpoint singularities inherited from the raw y-integrand, the function returns 0 when t is within eps of either endpoint.\n\nArguments\n\nt::T: Parameter in [0, 1].\n\nKeyword arguments\n\np::Int=2: Power used in the substitution y = t^p.\neps::T=T(1e-15): Endpoint cutoff. If t ≤ eps or 1 - t ≤ eps, returns 0.\n\nReturns\n\nT: The transformed integrand value g̃(t) (or zero near endpoints).\n\nNotes\n\nEndpoint suppression is implemented exactly (hard cutoff) to keep numerical behavior unchanged and to avoid non-finite weights in quadrature rules that sample near t = 0 or t = 1.\nThe function is generic in T<:Number so it can be used with AD / Taylor objects, but the cutoff comparisons (t ≤ eps) require an ordered type; this is intended for real-valued t.\n\nErrors\n\nThrows an error if p < 1 (implicitly, via t^(p-1) or user intent); no explicit check is performed here to preserve original behavior.\n\n\n\n\n\n","category":"method"},{"location":"lib/AvgErrFormatter/#Maranatha.AvgErrFormatter","page":"AvgErrFormatter","title":"Maranatha.AvgErrFormatter","text":"","category":"section"},{"location":"lib/AvgErrFormatter/#Maranatha.AvgErrFormatter.avgerr_e2d-Tuple{String, String}","page":"AvgErrFormatter","title":"Maranatha.AvgErrFormatter.avgerr_e2d","text":"avgerr_e2d(\n    censtr::String, \n    errstr::String\n) -> String\n\nFormat a central value and its error into a compact string using parenthetical pm notation.\n\nThis function takes the central value and error as strings in scientific notation (e.g., \"1.234e+01\", \"3.2e-01\"),  and returns a formatted string such as \"12.3(3)\". It handles different scales and adds a * suffix if the error dominates.\n\nArguments\n\ncenstr::String : Central value string in scientific notation.\nerrstr::String : Error value string in scientific notation.\n\nReturns\n\nString : Formatted result like \"1.23(45)\" or \"1.2(3) *\" depending on magnitude and dominance.\n\n\n\n\n\n","category":"method"},{"location":"lib/AvgErrFormatter/#Maranatha.AvgErrFormatter.avgerr_e2d_from_float-Tuple{Float64, Float64}","page":"AvgErrFormatter","title":"Maranatha.AvgErrFormatter.avgerr_e2d_from_float","text":"avgerr_e2d_from_float(\n    cen::Float64, \n    err::Float64\n) -> String\n\nConvert a central value and its error from Float64 into a compact exponential pm string.\n\nThis is a wrapper for avgerr_e2d that takes float inputs and internally converts them to scientific notation strings with high precision before formatting.\n\nArguments\n\ncen::Float64 : Central value.\nerr::Float64 : Error value.\n\nReturns\n\nString : Formatted output like \"1.23(4)e+02\" or \"1.2(3) *\".\n\n\n\n\n\n","category":"method"},{"location":"lib/AvgErrFormatter/#Maranatha.AvgErrFormatter.round_sig","page":"AvgErrFormatter","title":"Maranatha.AvgErrFormatter.round_sig","text":"round_sig(\n    x::Float64, \n    sig::Int=2\n) -> Float64\n\nRound a number to a specified number of significant digits.\n\nArguments\n\nx::Float64  : Number to round.\nsig::Int=2  : Number of significant digits (default: 2).\n\nReturns\n\nFloat64 : The number rounded to the specified significant digits.\n\n\n\n\n\n","category":"function"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator","text":"","category":"section"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator._boundary_error_params-Tuple{Symbol}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator._boundary_error_params","text":"_boundary_error_params(\n    rule::Symbol\n) -> (p, K, dord, off)\n\nReturn parameters for the boundary-difference leading-term error model associated with rule.\n\nFunction description\n\nThis routine provides a compact parameterization for boundary-difference error heuristics used by opened composite rules in error estimators.\n\nThe model is expressed in the form\n\nE approx textttK  h^textttp  ( D_L - D_R ) \n\nwhere\n\ndisplaystyleh = fracb-aN,\nD_L  = f^(textttm)(x_L) (or an axis-wise derivative in higher dimensions),\nD_R = f^(textttm)(x_R),\n\nand the evaluation points are placed symmetrically near both ends:\n\nx_L = a + textttz  h\nx_R = a + ( N - textttz )  h\n\nThis parameterization allows multidimensional error estimators to reuse the same boundary logic by applying the axis-wise boundary difference while integrating over the other coordinates via the quadrature weights.\n\nArguments\n\nrule::Symbol: Integration rule symbol.\n\nReturns\n\n(p, K, m, z) where:\np::Int      : leading power of h (i.e., the model scales as h^textttp),\nK::Float64  : prefactor multiplying the boundary difference,\nm::Int   : derivative order used in the boundary difference,\nz::Float64: offset (in units of h) used to define boundary sample points x_L = a + textttz  h and x_R = a + ( N - textttz )  h.\n\nIf rule is not supported, returns (0, 0.0, 0, 0.0).\n\nNotes\n\nThis is a heuristic leading-term model used to set a stable error scale for fitting/extrapolation. It is not a rigorous truncation bound.\nThe numerical constants are chosen to match the opened composite rule expansions used in this project:\n:simpson13_open uses a third-derivative boundary difference with h^4.\n:bode_open     uses a fifth-derivative boundary difference with h^6.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator._has_boundary_error_model-Tuple{Symbol}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator._has_boundary_error_model","text":"_has_boundary_error_model(\n    rule::Symbol\n) -> Bool\n\nReturn true if rule uses a boundary-difference leading-term error model.\n\nFunction description\n\nFor some opened composite (endpoint-free) rules, the dominant truncation behavior is often controlled by boundary corrections rather than a purely interior (midpoint) derivative sample.\n\nThis helper identifies the rule symbols for which the error estimators should switch from the default midpoint-based tensor heuristic to a boundary-difference model.\n\nArguments\n\nrule::Symbol: Integration rule symbol.\n\nReturns\n\nBool: true if a boundary-difference model is defined for rule, otherwise false.\n\nNotes\n\nCurrently enabled rules:\n:simpson13_open\n:bode_open\nAll other rules fall back to _rule_params_for_tensor_error(rule)-based midpoint/tensor heuristics.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator._rule_params_for_tensor_error-Tuple{Symbol}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator._rule_params_for_tensor_error","text":"_rule_params_for_tensor_error(\n    rule::Symbol\n)\n\nMap rule to the derivative order m and coefficient C used by the tensor-product derivative-based error heuristics in multidimensional error estimators.\n\nArguments\n\nrule: Integration rule symbol.\n\nReturns\n\n(m, C) where:\nm::Int is the derivative order used in the error estimator,\nC is the rule-dependent coefficient (kept as the same literal type as the original implementation).\n\nIf rule is not supported, returns (0, 0.0).\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator.estimate_error-NTuple{6, Any}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator.estimate_error","text":"estimate_error(\n    f, \n    a, \n    b, \n    N, \n    dim, \n    rule\n) -> Float64\n\nUnified interface for estimating integration error in arbitrary dimensions.\n\nFunction description\n\nDispatches to the corresponding dimension-specific estimator:\n\ndim == 1 rightarrow estimate_error_1d\ndim == 2 rightarrow estimate_error_2d\ndim == 3 rightarrow estimate_error_3d\ndim == 4 rightarrow estimate_error_4d\ndim >= 5 rightarrow estimate_error_nd\n\nArguments\n\nf: Integrand function (expects dim positional arguments).\na, b: Bounds for each dimension (interpreted as scalar bounds for a hypercube ab^textttdim).\nN: Number of subdivisions per axis (subject to rule constraints in 1-dimensional case; higher-dimensional error estimators reuse the same rule nodes/weights).\ndim: Number of dimensions (Int).\nrule: Integration rule symbol.\n\nReturns\n\nA Float64 multidimensional error estimate.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator.estimate_error_1d-Tuple{Any, Real, Real, Int64, Symbol}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator.estimate_error_1d","text":"estimate_error_1d(\n    f,\n    a::Real,\n    b::Real,\n    N::Int,\n    rule::Symbol\n) -> Float64\n\nReturn a fast 1-dimensional quadrature error scale for \n\nintlimits_a^b  dx  f(x)\n\nusing a lightweight derivative-based heuristic. \n\nFor selected opened composite rules, a boundary-difference proxy is used.  Derivatives are attempted with ForwardDiff.jl first,  with an automatic TaylorSeries.jl fallback when non-finite (Inf/NaN) values occur.\n\nFunction description\n\nThis routine provides a cheap, consistent error scale proxy intended to:\n\nsupply per-point weights sigma(h) for least-chi^2-fitting (Maranatha.FitConvergence.fit_convergence), and\nmatch the same h-scaling convention used by the multidimensional error estimators in this package.\n\nIt is not a rigorous truncation bound and does not attempt to reproduce the full composite-rule error expansion.\n\nTwo regimes are supported:\n\n(A) Boundary-difference model (for selected opened composite rules)\n\nFor rules flagged by _has_boundary_error_model(rule), the estimator uses a leading boundary-difference proxy of the form\n\nE approx textttK  h^textttp  ( D_L - D_R ) \n\nwhere\n\ndisplaystyleh = fracb-aN,\nx_L = a + textttz  h,\nx_R = a + ( N - textttz )  h,\n(p, K, m, z) =_boundary_error_params(rule).\n\nThis branch is designed for (endpoint-free) opened composite rule formulas whose leading error behavior can be boundary-dominant, and often improves least chi^2 fitting stability for those rules.\n\nDerivative evaluation and TaylorSeries.jl fallback\n\nAll derivatives in this routine are evaluated via the internal helper _nth_deriv_safe:\n\ncompute using nth_derivative (ForwardDiff.jl-based),\nif non-finite, emit a Maranatha.JobLoggerTools.warn_benji and retry with nth_derivative_taylor (TaylorSeries.jl-based),\nthrow an error only if the TaylorSeries.jl fallback is also non-finite.\n\n(B) Default midpoint tensor-style model (all other supported rules)\n\nOtherwise, the estimator follows the same single-sample midpoint derivative pattern used in the multidimensional error estimators:\n\nObtain (m, C) via _rule_params_for_tensor_error(rule).\nBuild 1-dimensional nodes/weights (xs, wx) via Maranatha.Integrate.quadrature_1d_nodes_weights(a, b, N, rule).\nEvaluate f^(m)(barx) once at the midpoint displaystylebarx = fraca+b2 (with the same fallback logic).\nForm the weight-sum prox displaystyleI = left( sum_j textttwxj right) ast f^(m)left( barx right). (Since the derivative sample is constant across nodes, this is equivalent to accumulating displaystyleleft( sum_j textttwxj right) ast f^(m)left( barx right).)\nReturn E = C  (b - a)  h^m  I.\n\nArguments\n\nf: Scalar callable integrand f(x) (function, closure, or callable struct).\na, b: Integration limits.\nN: Number of subintervals defining displaystyleh = fracb-aN.\nrule: Quadrature rule symbol.\n\nReturns\n\nFloat64: A heuristic (signed) error scale proxy. If m == 0 for the selected rule, returns 0.0.\n\nNotes\n\nSome rules may have negative quadrature weights. This estimator intentionally preserves the rule-defined weight sum displaystylesum_j textttwxj, rather than enforcing any normalization.\nRule-specific constraints on N (divisibility, minimum size, etc.) are:\nenforced explicitly in the boundary-model branch for supported open rules, and\nenforced in Maranatha.Integrate.quadrature_1d_nodes_weights for the default midpoint path.\nThe TaylorSeries.jl fallback requires the integrand to accept generic number types (e.g. Taylor1). If the integrand dispatch is restricted to Real only, the fallback may raise a MethodError.\n\nErrors\n\nThrows an error if (N, rule) violates rule constraints.\nThrows an error if both ForwardDiff.jl and TaylorSeries.jl derivatives are non-finite in the selected estimator branch.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator.estimate_error_2d-Tuple{Any, Real, Real, Int64, Symbol}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator.estimate_error_2d","text":"estimate_error_2d(\n    f,\n    a::Real,\n    b::Real,\n    N::Int,\n    rule::Symbol\n) -> Float64\n\nReturn a fast 2-dimensional quadrature error scale proxy for \n\nintlimits_a^b intlimits_a^b  dx dy  f(xy)\n\nusing a lightweight derivative-based tensor-product heuristic.\n\nFor selected opened composite rules, a boundary-difference proxy is used.  Derivatives are attempted with ForwardDiff.jl first,  with an automatic TaylorSeries.jl fallback when non-finite (Inf/NaN) values occur.\n\nFunction description\n\nThis routine provides a cheap, consistent error scale proxy intended to:\n\nsupply per-point weights sigma(h) for least-chi^2-fitting (Maranatha.FitConvergence.fit_convergence), and\nmatch the same h-scaling convention used by the multidimensional error estimators in this package.\n\nIt is not a rigorous truncation bound and does not attempt to reproduce the full composite-rule error expansion.\n\nTwo regimes are supported:\n\n(A) Boundary-difference model (selected opened composite rules)\n\nFor rules flagged by _has_boundary_error_model(rule), the error estimator applies an axis-wise boundary-difference proxy:\n\nAlong the x axis (integrate over y):\n\nI_x approx int dy  left partial_x^textttm f(x_Ly) - partial_x^textttm f(x_Ry) right\n\nAlong the y axis (integrate over x):\n\nI_y approx int dx  left partial_y^textttm f(xy_L) - partial_y^textttm f(xy_R) right\n\nand returns\n\nE approx textttK  h^textttp  ( I_x + I_y ) \n\nwhere\n\ndisplaystyleh = fracb-aN,\nx_L = a + textttz  h, x_R = a + ( N - textttz )  h (and similarly y_L, y_R),\n(p, K, m, z) =_boundary_error_params(rule).\n\nThis branch is designed for (endpoint-free) opened composite rule formulas whose leading error behavior can be boundary-dominant, and often improves least chi^2 fitting stability for those rules.\n\nDerivative evaluation and TaylorSeries.jl fallback\n\nAll derivatives in this routine are evaluated via the internal helper _nth_deriv_safe:\n\ncompute using nth_derivative (ForwardDiff.jl-based),\nif non-finite, emit a Maranatha.JobLoggerTools.warn_benji and retry with nth_derivative_taylor (TaylorSeries.jl-based),\nthrow an error only if the TaylorSeries.jl fallback is also non-finite.\n\n(B) Default midpoint tensor-style model (all other supported rules)\n\nOtherwise, the estimator follows the same single-sample midpoint derivative pattern used in the multidimensional error estimators:\n\nObtain (m, C) via _rule_params_for_tensor_error(rule).\nBuild 1-dimensional nodes/weights (xs, wx) via Maranatha.Integrate.quadrature_1d_nodes_weights(a, b, N, rule).\nApproximate two axis-wise contributions:\ndisplaystyleI_x = int dy  partial_x^textttm f(barxy) by sampling partial_x^textttmf at barx and integrating over y,   \ndisplaystyleI_y = int dx  partial_y^textttm f(xbary) by sampling partial_y^textttmf at bary and integrating over x.\nReturn E approx C  (b-a)  h^textttm  (I_x + I_y).\n\nArguments\n\nf: 2-dimensional integrand callable f(x, y) (function, closure, or callable struct).\na, b: Square domain bounds.\nN: Number of subdivisions per axis defining displaystyleh = fracb-aN.\nrule: Quadrature rule symbol.\n\nReturns\n\nFloat64: A heuristic (signed) error scale proxy. If m == 0 for the selected rule, returns 0.0.\n\nNotes\n\nSome rules may have negative quadrature weights. This estimator intentionally preserves the rule-defined weights rather than enforcing normalization.\nRule-specific constraints on N (divisibility, minimum size, etc.) are:\nenforced explicitly in the boundary-model branch for supported open rules, and\nenforced in Maranatha.Integrate.quadrature_1d_nodes_weights for the default midpoint path.\nThe TaylorSeries.jl fallback requires the integrand to accept generic number types (e.g. Taylor1). If the integrand dispatch is restricted to Real only, the fallback may raise a MethodError.\n\nErrors\n\nThrows an error if (N, rule) violates rule constraints.\nThrows an error if both ForwardDiff.jl and TaylorSeries.jl derivatives are non-finite in the selected estimator branch.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator.estimate_error_3d-Tuple{Any, Real, Real, Int64, Symbol}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator.estimate_error_3d","text":"estimate_error_3d(\n    f,\n    a::Real,\n    b::Real,\n    N::Int,\n    rule::Symbol\n) -> Float64\n\nReturn a fast 3-dimensional quadrature error scale proxy for the cube integral\n\nintlimits_a^b intlimits_a^b intlimits_a^b  dx dy dz  f(xyz)\n\nusing a lightweight derivative-based tensor-product heuristic.\n\nFor selected opened composite rules, a boundary-difference proxy is used.  Derivatives are attempted with ForwardDiff.jl first,  with an automatic TaylorSeries.jl fallback when non-finite (Inf/NaN) values occur.\n\nFunction description\n\nThis routine provides a cheap, consistent error scale proxy intended to:\n\nsupply per-point weights sigma(h) for least-chi^2-fitting (Maranatha.FitConvergence.fit_convergence), and\nmatch the same h-scaling convention used by the multidimensional error estimators in this package.\n\nIt is not a rigorous truncation bound and does not attempt to reproduce the full composite-rule error expansion.\n\nTwo regimes are supported:\n\n(A) Boundary-difference model (selected opened composite rules)\n\nFor rules flagged by _has_boundary_error_model(rule), the error estimator applies an axis-wise boundary-difference proxy. For each axis, it takes a boundary difference of the corresponding axis-wise derivative and integrates over the remaining coordinates:\n\nx-axis:\n\nI_x approx int int dy dz  left partial_x^textttm f(x_Lyz) - partial_x^textttm f(x_Ryz) right\n\ny-axis:\n\nI_y approx int int dz dx  left partial_y^textttm f(xy_Lz) - partial_y^textttm f(xy_Rz) right\n\nz-axis:\n\nI_z approx int int dx dy  left partial_z^textttm f(xyz_L) - partial_z^textttm f(xyz_R) right\n\nand returns\n\nE approx textttK  h^textttp  ( I_x + I_y + I_z ) \n\nwhere\n\ndisplaystyleh = fracb-aN,\nx_L = a + textttz  h, x_R = a + ( N - textttz )  h (and similarly y, z),\n(p, K, m, z) =_boundary_error_params(rule).\n\nThis branch is designed for (endpoint-free) opened composite rule formulas whose leading error behavior can be boundary-dominant, and often improves least chi^2 fitting stability for those rules.\n\nDerivative evaluation and TaylorSeries.jl fallback\n\nAll derivatives in this routine are evaluated via the internal helper _nth_deriv_safe:\n\ncompute using nth_derivative (ForwardDiff.jl-based),\nif non-finite, emit a Maranatha.JobLoggerTools.warn_benji and retry with nth_derivative_taylor (TaylorSeries.jl-based),\nthrow an error only if the TaylorSeries.jl fallback is also non-finite.\n\n(B) Default midpoint tensor-style model (all other supported rules)\n\nOtherwise, the estimator follows the same single-sample midpoint derivative pattern used in the multidimensional error estimators:\n\nObtain (m, C) via _rule_params_for_tensor_error(rule).\nBuild 1-dimensional nodes/weights (xs, wx) via Maranatha.Integrate.quadrature_1d_nodes_weights(a, b, N, rule).\nApproximate three axis-wise contributions by integrating the m-th derivative along one axis while holding the remaining coordinates on quadrature nodes:\ndisplaystyleI_x = int int dy dz  partial_x^textttm f(barxyz)\ndisplaystyleI_y = int int dz dx  partial_y^textttm f(xbaryz)\ndisplaystyleI_z = int int dx dy  partial_z^textttm f(xybarz)\nReturn E approx C  (b-a)  h^textttm  (I_x + I_y + I_z).\n\nArguments\n\nf: 3-dimensional integrand callable f(x, y, z) (function, closure, or callable struct).\na, b: Cube domain bounds.\nN: Number of subdivisions per axis defining displaystyleh = fracb-aN.\nrule: Quadrature rule symbol.\n\nReturns\n\nFloat64: A heuristic (signed) error scale proxy. If m == 0 for the selected rule, returns 0.0.\n\nNotes\n\nSome rules may have negative quadrature weights. This estimator intentionally preserves the rule-defined weights rather than enforcing normalization.\nRule-specific constraints on N (divisibility, minimum size, etc.) are:\nenforced explicitly in the boundary-model branch for supported open rules, and\nenforced in Maranatha.Integrate.quadrature_1d_nodes_weights for the default midpoint path.\nThe TaylorSeries.jl fallback requires the integrand to accept generic number types (e.g. Taylor1). If the integrand dispatch is restricted to Real only, the fallback may raise a MethodError.\n\nErrors\n\nThrows an error if (N, rule) violates rule constraints.\nThrows an error if both ForwardDiff.jl and TaylorSeries.jl derivatives are non-finite in the selected estimator branch.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator.estimate_error_4d-Tuple{Any, Real, Real, Int64, Symbol}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator.estimate_error_4d","text":"estimate_error_4d(\n    f,\n    a::Real,\n    b::Real,\n    N::Int,\n    rule::Symbol\n) -> Float64\n\nReturn a fast 4-dimensional quadrature error scale proxy for the hypercube integral\n\nintlimits_a^b intlimits_a^b intlimits_a^b intlimits_a^b  dx dy dz dt  f(xyzt)\n\nusing a lightweight derivative-based tensor-product heuristic.\n\nFor selected opened composite rules, a boundary-difference proxy is used.  Derivatives are attempted with ForwardDiff.jl first,  with an automatic TaylorSeries.jl fallback when non-finite (Inf/NaN) values occur.\n\nFunction description\n\nThis routine provides a cheap, consistent error scale proxy intended to:\n\nsupply per-point weights sigma(h) for least-chi^2-fitting (Maranatha.FitConvergence.fit_convergence), and\nmatch the same h-scaling convention used by the multidimensional error estimators in this package.\n\nIt is not a rigorous truncation bound and does not attempt to reproduce the full composite-rule error expansion.\n\nTwo regimes are supported:\n\n(A) Boundary-difference model (selected opened composite rules)\n\nFor rules flagged by _has_boundary_error_model(rule), the error estimator applies an axis-wise boundary-difference proxy. For each axis, it takes a boundary difference of the corresponding axis-wise derivative and integrates over the remaining coordinates:\n\nx-axis:\n\nI_x approx int int int dy dz dt  left partial_x^textttm f(x_Lyzt) - partial_x^textttm f(x_Ryzt) right\n\ny-axis:\n\nI_y approx int int int dz dt dx  left partial_y^textttm f(xy_Lzt) - partial_y^textttm f(xy_Rzt) right\n\nz-axis:\n\nI_z approx int int int dt dx dy  left partial_z^textttm f(xyz_Lt) - partial_z^textttm f(xyz_Rt) right\n\nt-axis:\n\nI_t approx int int int dx dy dz  left partial_t^textttm f(xyzt_L) - partial_t^textttm f(xyzt_R) right\n\nand returns\n\nE approx textttK  h^textttp  ( I_x + I_y + I_z + I_t ) \n\nwhere\n\ndisplaystyleh = fracb-aN,\nx_L = a + textttz  h, x_R = a + ( N - textttz )  h (and similarly y, z, t),\n(p, K, m, z) =_boundary_error_params(rule).\n\nThis branch is designed for (endpoint-free) opened composite rule formulas whose leading error behavior can be boundary-dominant, and often improves least chi^2 fitting stability for those rules.\n\nDerivative evaluation and TaylorSeries.jl fallback\n\nAll derivatives in this routine are evaluated via the internal helper _nth_deriv_safe:\n\ncompute using nth_derivative (ForwardDiff.jl-based),\nif non-finite, emit a Maranatha.JobLoggerTools.warn_benji and retry with nth_derivative_taylor (TaylorSeries.jl-based),\nthrow an error only if the TaylorSeries.jl fallback is also non-finite.\n\n(B) Default midpoint tensor-style model (all other supported rules)\n\nOtherwise, the estimator follows the same single-sample midpoint derivative pattern used in the multidimensional error estimators:\n\nObtain (m, C) via _rule_params_for_tensor_error(rule).\nBuild 1-dimensional nodes/weights (xs, wx) via Maranatha.Integrate.quadrature_1d_nodes_weights(a, b, N, rule).\nApproximate four axis-wise contributions by integrating the m-th derivative along one axis while holding the remaining coordinates on quadrature nodes:\ndisplaystyleI_x = int int int dy dz dt  partial_x^textttm f(barxyzt)\ndisplaystyleI_y = int int int dz dt dx  partial_y^textttm f(xbaryzt)\ndisplaystyleI_z = int int int dt dx dy  partial_z^textttm f(xybarzt)\ndisplaystyleI_t = int int int dt dx dy  partial_t^textttm f(xyzbart)\nReturn E approx C  (b-a)  h^textttm  (I_x + I_y + I_z + I_t).\n\nArguments\n\nf: 4-dimensional integrand callable f(x, y, z, t) (function, closure, or callable struct).\na, b: Hypercube domain bounds.\nN: Number of subdivisions per axis defining displaystyleh = fracb-aN.\nrule: Quadrature rule symbol.\n\nReturns\n\nFloat64: A heuristic (signed) error scale proxy. If m == 0 for the selected rule, returns 0.0.\n\nNotes\n\nSome rules may have negative quadrature weights. This estimator intentionally preserves the rule-defined weights rather than enforcing normalization.\nRule-specific constraints on N (divisibility, minimum size, etc.) are:\nenforced explicitly in the boundary-model branch for supported open rules, and\nenforced in Maranatha.Integrate.quadrature_1d_nodes_weights for the default midpoint path.\nThe TaylorSeries.jl fallback requires the integrand to accept generic number types (e.g. Taylor1). If the integrand dispatch is restricted to Real only, the fallback may raise a MethodError.\n\nErrors\n\nThrows an error if (N, rule) violates rule constraints.\nThrows an error if both ForwardDiff.jl and TaylorSeries.jl derivatives are non-finite in the selected estimator branch.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator.estimate_error_nd-Tuple{Any, Real, Real, Int64, Symbol}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator.estimate_error_nd","text":"estimate_error_nd(\n    f,\n    a::Real,\n    b::Real,\n    N::Int,\n    rule::Symbol;\n    dim::Int\n) -> Float64\n\nReturn a fast d-dimensional quadrature error scale proxy for the hypercube integral, where d = textttdim,\n\nintlimits_ab^d d^d x  f(x_1x_2ldotsx_d)\n\nusing a lightweight derivative-based tensor-product heuristic.\n\nThis routine generalizes the dimension-specific error estimators, estimate_error_1d/estimate_error_2d/estimate_error_3d/estimate_error_4d into a single dimension-agnostic model, while preserving the same loop ordering and accumulation structure.\n\nFor selected opened composite rules, a boundary-difference proxy is used.  Derivatives are attempted with ForwardDiff.jl first,  with an automatic TaylorSeries.jl fallback when non-finite (Inf/NaN) values occur.\n\nFunction description\n\nThis routine provides a cheap, consistent error scale proxy intended to:\n\nsupply per-point weights sigma(h) for least-chi^2-fitting (Maranatha.FitConvergence.fit_convergence), and\nmatch the same h-scaling convention used by the multidimensional error estimators in this package.\n\nIt is not a rigorous truncation bound and does not attempt to reproduce the full composite-rule error expansion.\n\nTwo regimes are supported:\n\n(A) Boundary-difference model (selected open-chain rules)\n\nFor rules where _has_boundary_error_model(rule) is true, a boundary-based leading-term model is applied axis by axis.\n\nDefine boundary points\n\n- x_L = a + textttz  h quad x_R = a + ( N - textttz )  h\n\nwhere displaystyleh = fracb-aN and (p, K, m, z) =_boundary_error_params(rule).\n\nFor each axis mu = 1 ldots  d, construct\n\nI_mu = intlimits_ab^d-1 d^d-1 x  left partial_mu^textttm f(ldotsx_Lldots) - partial_mu^textttm f(ldotsx_Rldots) right\n\nand return\n\nE approx textttK  h^textttp  sum_mu I_mu \n\nThis boundary-difference structure models the dominant truncation behavior of certain opened composite (endpoint-free) rule formulas and typically improves least chi^2 fitting stability during h to 0 extrapolation.\n\nDerivative evaluation and TaylorSeries.jl fallback\n\nAll derivatives in this routine are evaluated via the internal helper _nth_deriv_safe:\n\ncompute using nth_derivative (ForwardDiff.jl-based),\nif non-finite, emit a Maranatha.JobLoggerTools.warn_benji and retry with nth_derivative_taylor (TaylorSeries.jl-based),\nthrow an error only if the TaylorSeries.jl fallback is also non-finite.\n\nRule-specific constraints on N (divisibility, minimum size, etc.) are enforced explicitly in this branch for supported opened composite rules.\n\n(B) Default midpoint tensor-style model (all other supported rules)\n\nOtherwise, the error estimator falls back to the midpoint tensor-product heuristic:\n\nObtain (m, C) via _rule_params_for_tensor_error(rule).\nBuild 1-dimensional nodes/weights (xs, wx) via Maranatha.Integrate.quadrature_1d_nodes_weights(a, b, N, rule).\nFor each axis mu, integrate the m-th axis derivative over the remaining coordinates using tensor-product weights, by sampling partial_mu^textttm f at the midpoint along that axis and enumerating quadrature nodes on the other axes (mirroring the legacy loop structure).\nReturn E approx C  (b-a)  h^textttm   sum_mu I_mu.\n\nArguments\n\nf: Integrand callable accepting dim scalar arguments.\na, b: Domain bounds defining the hypercube ab^d.\nN: Number of subdivisions per axis (displaystyleh = fracb-aN).\nrule: Integration rule symbol.\ndim: Number of spatial dimensions (must satisfy dimge 1).\n\nReturns\n\nFloat64: A heuristic (signed) error scale proxy. If m == 0 for the selected rule, returns 0.0.\n\nImplementation notes\n\nThe loop ordering, accumulation structure, and floating-point behavior intentionally mirror the dimension-specific implementations for reproducibility.\nThe helper _call_with_axis dynamically replaces one coordinate while keeping the remaining axes fixed, enabling AD-compatible evaluation along the differentiated axis.\nSome rules may have negative quadrature weights; this estimator intentionally preserves the rule-defined weights rather than enforcing normalization.\n\nLimitations\n\nThis estimator is not a rigorous error bound; it provides only a leading scaling model suitable for convergence fitting.\nComputational cost scales as O(d  textttlength(xs)^textttdim-1 ), which grows rapidly with dim.\nThe TaylorSeries.jl fallback requires the integrand to accept generic number types (e.g. Taylor1). If the integrand dispatch is restricted to Real only, the fallback may raise a MethodError.\n\nErrors\n\nThrows an error if dim < 1.\nThrows an error if (N, rule) violates rule constraints.\nThrows an error if both ForwardDiff.jl and TaylorSeries.jl derivatives are non-finite in the selected estimator branch.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator.nth_derivative-Tuple{Any, Real, Int64}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator.nth_derivative","text":"nth_derivative(\n    f, \n    x::Real, \n    n::Int\n)\n\nCompute the n-th derivative of a scalar callable f at a scalar point x using repeated ForwardDiff.derivative.\n\nFunction description\n\nThis routine is intentionally written to accept any callable object f, not only subtypes of Function. This includes:\n\nordinary functions,\nanonymous closures,\ncallable structs (functors) such as preset integrands.\n\nThis design is required for compatibility with the integrand registry and preset-style callable wrappers while preserving ForwardDiff.jl-based behavior.\n\nArguments\n\nf: Scalar-to-scalar callable (e.g., f(x)::Number).\nx::Real: Point at which the derivative is evaluated.\nn::Int: Derivative order (nonnegative integer).\n\nReturns\n\nThe n-th derivative value f^(n)(x).\n\nNotes\n\nThis implementation constructs a nested closure chain of length n and then evaluates it at x. This intentionally matches the original behavior.\nType restriction f::Function is intentionally avoided because callable structs are not subtypes of Function, but must be supported.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator.nth_derivative_enzyme-Tuple{Any, Real, Int64}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator.nth_derivative_enzyme","text":"nth_derivative_enzyme(\n    f,\n    x::Real,\n    n::Int\n)\n\nCompute the n-th derivative of a scalar callable f at a scalar point x using repeated reverse-mode differentiation via Enzyme.jl.\n\nFunction description\n\nThis routine constructs a nested closure chain of length n, where each step applies Enzyme.gradient in reverse mode to obtain a first derivative. The resulting callable is then evaluated at x.\n\nThis mirrors the structure of the ForwardDiff.jl-based implementation but replaces forward-mode differentiation with Enzyme.jl's reverse-mode AD. It is intended primarily for benchmarking and experimentation with Enzyme.jl in scalar high-order differentiation contexts.\n\nSupported callable types include:\n\nordinary functions,\nanonymous closures,\ncallable structs (functors).\n\nArguments\n\nf: Scalar-to-scalar callable (f(x)::Number expected).\nx::Real: Evaluation point.\nn::Int: Derivative order (must be nonnegative).\n\nReturns\n\nThe n-th derivative value f^(n)(x).\n\nNotes\n\nReverse-mode AD is typically advantageous for many-input/one-output problems. For repeated scalar higher-order derivatives, performance may be worse than ForwardDiff.jl due to closure nesting and gradient reconstruction overhead.\nThis implementation intentionally preserves the closure-based structure for fair benchmarking against other approaches.\nInputs are converted to Float64 to match surrounding numeric conventions.\nProvided as a benchmarking reference implementation, not as the recommended production path in the current codebase.\n\n\n\n\n\n","category":"method"},{"location":"lib/ErrorEstimator/#Maranatha.ErrorEstimator.nth_derivative_taylor-Tuple{Any, Real, Int64}","page":"ErrorEstimator","title":"Maranatha.ErrorEstimator.nth_derivative_taylor","text":"nth_derivative_taylor(\n    f,\n    x::Real,\n    n::Int\n)\n\nCompute the n-th derivative of a scalar callable f at a scalar point x using a Taylor expansion via TaylorSeries.jl.\n\nFunction description\n\nThis routine evaluates the Taylor expansion of f(x + t) around x up to order n using a TaylorSeries.Taylor1 expansion variable.   The n-th derivative is obtained from the n-th Taylor coefficient multiplied by n.\n\nUnlike the ForwardDiff.jl implementation, this method performs higher-order differentiation in a single pass rather than recursively applying first derivatives. It is useful for benchmarking alternative AD strategies and for testing high-order derivative extraction based on truncated power-series arithmetic.\n\nThis function accepts any callable object f, including:\n\nordinary functions,\nanonymous closures,\ncallable structs (functors).\n\nArguments\n\nf: Scalar-to-scalar callable (f(x)::Number expected).\nx::Real: Evaluation point.\nn::Int: Derivative order (must be nonnegative).\n\nReturns\n\nThe n-th derivative value f^(n)(x).\n\nNotes\n\nInternally converts x to Float64 to match the surrounding numeric policy.\nThis method may allocate significantly more memory than ForwardDiff.jl, especially when used inside large loops or with high expansion orders.\n\n\n\n\n\n","category":"method"},{"location":"lib/F0000Preset/#Maranatha.F0000Preset","page":"F0000Preset","title":"Maranatha.F0000Preset","text":"","category":"section"},{"location":"lib/F0000Preset/#Maranatha.F0000Preset.F0000Integrand","page":"F0000Preset","title":"Maranatha.F0000Preset.F0000Integrand","text":"struct F0000Integrand\n\nCallable wrapper integrand for the F0000 computation on t ∈ [0, 1].\n\nstruct description\n\nThis struct provides a user-friendly, callable integrand object that can be passed directly to Maranatha.Runner.run_Maranatha. Internally, it delegates to\n\nF0000GammaEminus1.gtilde_F0000(t; p=p, eps=eps),\n\nwhich implements the transformed integrand after the substitution y = t^p for the original F0000 integral.\n\nFields\n\np::Int: Power in the substitution y = t^p (integer, typically 2–4).\neps::Float64: Endpoint cutoff (stored as Float64) used by gtilde_F0000 to suppress singular behavior near t = 0 and t = 1.\n\nNotes\n\nTo remain compatible with automatic differentiation (e.g., ForwardDiff.Dual values of t), this wrapper stores eps as Float64 but converts it to typeof(t) at call time.\nThis preserves the original numerical behavior for normal Float64 usage while preventing keyword-type mismatches under AD.\n\n\n\n\n\n","category":"type"},{"location":"lib/F0000Preset/#Maranatha.F0000Preset.F0000Integrand-Tuple{Any}","page":"F0000Preset","title":"Maranatha.F0000Preset.F0000Integrand","text":"(f::F0000Integrand)(t)\n\nEvaluate the F0000 transformed integrand at t.\n\nArguments\n\nt: Real scalar in [0, 1] (may also be a dual number under AD).\n\nReturns\n\nThe value of g̃(t) as returned by F0000GammaEminus1.gtilde_F0000(t; p=f.p, eps=convert(typeof(t), f.eps)).\n\nNotes\n\neps is converted to typeof(t) to keep the keyword argument type-consistent when t is a ForwardDiff.Dual.\n\n\n\n\n\n","category":"method"},{"location":"lib/F0000Preset/#Maranatha.F0000Preset.__register_F0000_integrand__-Tuple{}","page":"F0000Preset","title":"Maranatha.F0000Preset.__register_F0000_integrand__","text":"__register_F0000_integrand__()\n\nRegister the :F0000 integrand factory into Maranatha.Integrands.\n\nFunction description\n\nThis function installs the factory factory_F0000 into the project-wide integrand registry, enabling the user-facing construction:\n\nMaranatha.Integrands.integrand(:F0000; p=..., eps=...).\n\nReturns\n\nnothing\n\nNotes\n\nThis is intended to be called once during package/module initialization (e.g., from src/Maranatha.jl after including this file).\n\n\n\n\n\n","category":"method"},{"location":"lib/F0000Preset/#Maranatha.F0000Preset.factory_F0000-Tuple{}","page":"F0000Preset","title":"Maranatha.F0000Preset.factory_F0000","text":"factory_F0000(; \n  p::Int=2, \n  eps::Float64=1e-15\n)\n\nFactory for constructing the registered F0000 integrand.\n\nFunction description\n\nThis factory is registered under the name :F0000 in the integrand registry. It returns a callable F0000Integrand instance that can be used as a standard integrand function.\n\nKeyword arguments\n\np::Int=2: Substitution power used in y = t^p.\neps::Float64=1e-15: Endpoint cutoff forwarded to gtilde_F0000.\n\nReturns\n\nF0000Integrand: Callable integrand object.\n\nNotes\n\neps is stored as Float64 but promoted to typeof(t) when evaluating the integrand. This makes the preset safe under ForwardDiff while keeping the default behavior deterministic for typical Float64 runs.\n\n\n\n\n\n","category":"method"},{"location":"#Maranatha.jl-Project-Documentation","page":"Home","title":"Maranatha.jl Project Documentation","text":"Welcome to the documentation for the Maranatha.jl!","category":"section"},{"location":"#Maranatha.Maranatha","page":"Home","title":"Maranatha.Maranatha","text":"module Maranatha\n\nMaranatha.jl is a modular Newton-Cotes-based toolkit for multi-resolution numerical integration, error-scale modeling, and chi^2-based convergence extrapolation on hypercube domains left a b right^n where n is the (spacetime) dimensionality.\n\nRather than exposing individual quadrature implementations directly, Maranatha.jl is designed around a pipeline-oriented workflow:\n\nintegration\nerror estimation\nh to 0 extrapolation via least chi^2 fitting\nvisualization using PyPlot.jl.\n\nThe internal structure is intentionally split into small, independent modules so that numerical components, logging, plotting, and preset integrands can evolve without tightly coupling the codebase.\n\nArchitecture overview\n\nIntegration layer\n\nMaranatha.Integrate module provides a unified front-end for tensor-product Newton-Cotes quadrature in arbitrary dimensions. The concrete rule implementations are kept internal and are not part of the public API surface.\n\nError modeling\n\nThe Maranatha.ErrorEstimator module supplies lightweight derivative-based error (scale) estimators that follow a tensor-product philosophy across dimensions. For selected endpoint-free rules, boundary-difference leading-term models are used to improve chi^2 stability.\n\nThis estimator is not rigorous truncation bound; it is designed to produce consistent scaling weights for least chi^2 fitting for h to 0 extrapolation.\n\nLeast chi^2 fitting\n\nMaranatha.FitConvergence submodule performs least chi^2 fitting for h to 0 extrapolation using a rule-dependent model\n\nI(h) = I_0 + C_1  h^p + C_2  h^p+2 + \n\nand returns parameter covariance, enabling uncertainty propagation into plots.\n\nIntegrand system\n\nThe Maranatha.Integrands submodule implements a registry-based preset system that allows named integrands to be constructed via factories while still accepting plain Julia callables (functions, closures, callable structs).\n\nThis design keeps user-facing workflows simple without sacrificing flexibility.\n\nExecution layer\n\nMaranatha.Runner.run_Maranatha is the main orchestration entry point.   It performs:\n\nmulti-resolution integration,\nerror-scale estimation,\nleast chi^2 fitting for h to 0 extrapolation,\nformatted reporting of results.\n\nUsers typically interact only with this high-level interface.\n\nPlotting utilities\n\nMaranatha.PlotTools.plot_convergence_result generates publication-style convergence figures using PyPlot.jl with LaTeX rendering. The shaded band represents the full covariance-propagated 1  sigma uncertainty of the fitted model.\n\nLogging\n\nAll runtime diagnostics are handled by Maranatha.JobLoggerTools, which provides timestamped logging, stage delimiters, and timing macros used consistently throughout the pipeline.\n\nPublic API\n\nThe top-level Maranatha namespace re-exports a minimal set of entry points:\n\nMaranatha.Runner.run_Maranatha   Perform numerical integration, error estimation, and least chi^2 fitting for h to 0 extrapolation.\nMaranatha.PlotTools.plot_convergence_result   Visualize convergence behavior and fitted uncertainty bands.\n\nInternal submodules remain accessible but are not required for normal usage.\n\nDimensionality\n\nDimension-specific error estimators exist for low dimensions, along with a generalized n-dimensional implementation following the same tensor-product philosophy. Because tensor enumeration scales rapidly with dimension, higher-dimensional usage is primarily intended for controlled numerical studies.\n\nDesign goals\n\nPipeline-oriented structure rather than rule-centric APIs.\nStrict separation between numerical core, orchestration, and visualization.\nReproducible floating-point behavior through preserved loop ordering.\nMinimal public API surface with extensible internal modules.\n\n\n\n\n\n","category":"module"}]
}
